/*******************************************************************************
 * Copyright 2018 T Mobile, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package com.tmobile.pacman.api.vulnerability.service;

import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.util.CollectionUtils;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.base.Strings;
import com.tmobile.pacman.api.commons.Constants;
import com.tmobile.pacman.api.commons.exception.DataException;
import com.tmobile.pacman.api.commons.exception.ServiceException;
import com.tmobile.pacman.api.commons.repo.ElasticSearchRepository;
import com.tmobile.pacman.api.commons.utils.CommonUtils;
import com.tmobile.pacman.api.commons.utils.ResponseUtils;
import com.tmobile.pacman.api.vulnerability.client.AssetServiceClient;
import com.tmobile.pacman.api.vulnerability.client.ComplianceServiceClient;
import com.tmobile.pacman.api.vulnerability.domain.AssetApi;
import com.tmobile.pacman.api.vulnerability.domain.AssetApiData;
import com.tmobile.pacman.api.vulnerability.domain.AssetCount;
import com.tmobile.pacman.api.vulnerability.domain.AssetCountByAppEnvDTO;
import com.tmobile.pacman.api.vulnerability.domain.AssetCountDTO;
import com.tmobile.pacman.api.vulnerability.domain.AssetCountData;
import com.tmobile.pacman.api.vulnerability.domain.Request;
import com.tmobile.pacman.api.vulnerability.domain.ResponseData;
import com.tmobile.pacman.api.vulnerability.domain.TrendNote;
import com.tmobile.pacman.api.vulnerability.repository.VulnerabilityRepository;
import com.tmobile.pacman.api.vulnerability.repository.VulnerabilityTrendGenerator;
import com.tmobile.pacman.api.vulnerability.repository.VulnerabilityTrendGenerator2;

/**
 * The Class VulnerabilityService.
 */
@Service
public class VulnerabilityService implements Constants {

	/** The vulnerability repository. */
	@Autowired
	private VulnerabilityRepository vulnerabilityRepository;

	/** The vuln trend generator. */
	@Autowired
	VulnerabilityTrendGenerator2 vulnTrendGenerator;
	


	/** The compliance service. */
	// @Autowired
	// ComplianceService complianceService;

	/** The vuln types. */
	@Value("${vulnerability.types}")
	private String vulnTypes;

	/** The vuln summary severity. */
	@Value("${vulnerability.summary.severity}")
	private String vulnSummarySeverity;

	/** The vuln application occurrence fields. */
	@Value("${vulnerability.application.occurance}")
	private String vulnOccurrenceFields;

	/** The vuln resource Id fields. */
	@Value("${vulnerability.application.resourcedetails}")
	private String vulnResourceIdFields;

	/** The vuln resource Id fields for both Ec2 and onprem. */
	@Value("${vulnerability.application.resourcedetailsboth}")
	private String vulnResourceIdFieldsBoth;

	/** The asset service client. */
	@Autowired
	private AssetServiceClient assetServiceClient;
	@Autowired
	private ComplianceServiceClient complianceServiceClient;

	/** The es repository. */
	@Autowired
	ElasticSearchRepository esRepository;

	/** The Constant logger. */
	private static final Log logger = LogFactory.getLog(VulnerabilityService.class);

	/**
	 * Gets the vulnerabilities details.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param filter
	 *            the filter
	 * @return the vulnerabilities details
	 * @throws Exception
	 *             the exception
	 */
	public List<Map<String, Object>> getVulnerabilitiesDetails(String assetGroup, Map<String, String> filter)
			throws Exception {
		List<Map<String, Object>> vulnerabilitiesDetails = new ArrayList<>();
		try {
			List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
			if (!vulnTargetTypes.isEmpty()) {
				for (String parentType : vulnTargetTypes) {
					Map<String, Long> vulnAssetsAffected = vulnerabilityRepository.getAssetsAffectedCount(assetGroup,
							filter, parentType);
					List<Map<String, Object>> vulnerabilitiesData = formVulnerabilitiesData(vulnerabilityRepository
							.getAllVulnerabilities(new ArrayList<String>(vulnAssetsAffected.keySet())),
							vulnAssetsAffected);
					List<Map<String, Object>> vulnerabilitiesDetailsTemp = new ArrayList<>();
					if (vulnerabilitiesDetails.isEmpty()) {
						vulnerabilitiesDetails = new ArrayList<>(vulnerabilitiesData);
					} else {
						for (Map<String, Object> vulnData : vulnerabilitiesData) {
							boolean qidMatched = false;
							for (Map<String, Object> vulnDetail : vulnerabilitiesDetails) {
								if (vulnData.get("qid").equals(vulnDetail.get("qid"))) {
									vulnDetail.put(ASSETS_AFFECTED,
											Long.valueOf(vulnDetail.get(ASSETS_AFFECTED).toString())
													+ Long.valueOf(vulnData.get(ASSETS_AFFECTED).toString()));
									qidMatched = true;
									break;
								}
							}
							if (!qidMatched) {
								vulnerabilitiesDetailsTemp.add(vulnData);
							}
						}
						vulnerabilitiesDetails.addAll(vulnerabilitiesDetailsTemp);
					}
				}
			}

		} catch (Exception e) {
			logger.error("Error in getVulnerabilitiesDetails ", e);
			throw e;
		}

		return vulnerabilitiesDetails;
	}

	@SuppressWarnings("unchecked")
	public List<Map<String, Object>> getAllVulnerabilitiesDetailsByAssetGroup(String assetGroup,
			Map<String, String> filter,String applicationFilter,String environmentFilter, String searchText, int from, int size) throws Exception {
		List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
		boolean flag = false;
		if (vulnTargetTypes.size() > 1) {
			flag = true;
		}
		List<Map<String, Object>> vulnerabilitiesDetails = new ArrayList<>();
		List<Map<String, Object>> vulnerabilitiesDetailsFinal = new ArrayList<>();
	/*	Map<String, Object> mustFilter = new HashMap<>();
		Map<String, Object> mustTermsFilter = new HashMap<>();
		mustFilter.put("latest", "true");
		for (Map.Entry<String, String> entry : filter.entrySet()) {
			List<String> severities = Arrays.asList(entry.getValue().split(","));
			mustTermsFilter.put(entry.getKey(), severities);
		}
		String targetType = "vulninfo";
		List<String> occurrenceFieldList = Arrays.asList(vulnOccurrenceFields.split(","));*/
		List<String> occurrenceFieldList = Arrays.asList(vulnOccurrenceFields.split(","));
		for (String parentType : vulnTargetTypes) {
		String targetType = "vulninfo";
		Map<String, Object> mustFilterMap = new LinkedHashMap<>();
		mustFilterMap.put("latest", "true");
		Map<String, Object> parentBool = new HashMap<>();
		List<Map<String, Object>> mustList = new ArrayList<>();
		Map<String, Object> matchMap = new HashMap<>();
		Map<String, String> match = new HashMap<>();
		Map<String, Object> mustTermsFilter = new HashMap<>();
		for (Map.Entry<String, String> entry : filter.entrySet()) {
			List<String> severities = Arrays.asList(entry.getValue().split(","));
			mustTermsFilter.put(entry.getKey(), severities);
		}
		// mustFilterMap.putAll(mustTermsFilter);
		match.put(Constants.LATEST, Constants.TRUE);
		matchMap.put(Constants.MATCH, match);
		mustList.add(matchMap);

		if (applicationFilter != null) {
			Map<String, String> applicationFilterMap = new HashMap<String, String>();
			Map<String, Object> applicationFilterMap1 = new HashMap<String, Object>();
			applicationFilterMap.put("tags.Application.keyword", applicationFilter);
			applicationFilterMap1.put("match", applicationFilterMap);
			mustList.add(applicationFilterMap1);
		}

		if (environmentFilter != null) {
			Map<String, String> environmentFilterMap = new HashMap<String, String>();
			Map<String, Object> environmentFilterMap1 = new HashMap<String, Object>();
			environmentFilterMap.put("tags.Environment.keyword", environmentFilter);
			environmentFilterMap1.put("match", environmentFilterMap);
			mustList.add(environmentFilterMap1);
		}

		parentBool.put("must", mustList);
		Map<String, Object> queryMap = new HashMap<>();
		queryMap.put("bool", parentBool);
		Map<String, Object> parentEntryMap = new LinkedHashMap<>();
		parentEntryMap.put("parent_type", parentType);
		parentEntryMap.put("query", queryMap);
		mustFilterMap.put("has_parent", parentEntryMap);
		
		try {

			vulnerabilitiesDetails = vulnerabilityRepository.getAllVulnerabilitiesByAssetGroup(assetGroup, targetType, mustFilterMap,occurrenceFieldList, from, size,
					mustTermsFilter);
			vulnerabilitiesDetailsFinal.addAll(vulnerabilitiesDetails);
		} catch (Exception e) {
			logger.error("Error in getAllVulnerabilitiesDetailsByAssetGroup ", e);
			throw e;
		}
		}
		List<String> listDistinctResourceId = getResourceId(vulnerabilitiesDetailsFinal);
		List<Map<String, Object>> resourceIdDetails = getResourcedetailsByResourceId(assetGroup, listDistinctResourceId,
				flag);

		List<Map<String, Object>> cartesianResultList = getCartesianProduct(vulnerabilitiesDetailsFinal, resourceIdDetails);
		cartesianResultList = (List<Map<String, Object>>) filterMatchingCollectionElements(cartesianResultList,
				searchText, true);
		for (Map<String, Object> map : cartesianResultList) {
			List<String> underscoreKeys = new ArrayList<String>();
			for (Map.Entry<String, Object> entry : map.entrySet()) {
				if (entry.getKey().startsWith("_")) {
					underscoreKeys.add(entry.getKey());
				}
			}
			underscoreKeys.forEach(underscoreElement -> {
				String underscoreRemovedKey = underscoreElement.substring(1, underscoreElement.length());
				map.put(underscoreRemovedKey, map.get(underscoreElement));
				map.remove(underscoreElement);
			});
		}

		return cartesianResultList;
	}

	public List<Map<String, Object>> getResourcedetailsByResourceId(String assetGroup,
			List<String> listDistinctResourceId, boolean flag) throws Exception {
		List<Map<String, Object>> resourceDetails = new ArrayList<>();
		Map<String, Object> mustFilter = new HashMap<>();
		Map<String, Object> mustTermFilter = new HashMap<>();
		mustFilter.put("_entity", "true");
		// mustFilter.put("latest", "true");
		List<String> resourceFieldList = Arrays.asList(vulnResourceIdFields.split(","));
		List<String> resourceFieldListBoth = Arrays.asList(vulnResourceIdFieldsBoth.split(","));
		Map<String, Object> queryMap2 = new HashMap<>();
		Map<String, Object> queryMap1 = new HashMap<>();
		Map<String, Object> mustFilterAddition = new HashMap<>();
		queryMap1.put("latest", "true");
		queryMap2.put("match", queryMap1);
		mustFilterAddition.put("type", "vulninfo");
		mustFilterAddition.put("query", queryMap2);
		mustFilter.put("has_child", mustFilterAddition);
		if (listDistinctResourceId != null && listDistinctResourceId.size() <= 1024) {
			mustTermFilter.put("_resourceid.keyword", listDistinctResourceId);
		} else {
			mustTermFilter = null;
		}

		try {

			if (flag == true) {

				resourceDetails = vulnerabilityRepository.getDetailsByResourceId(assetGroup, mustFilter,
						resourceFieldListBoth, mustTermFilter);
			} else {
				resourceDetails = vulnerabilityRepository.getDetailsByResourceId(assetGroup, mustFilter,
						resourceFieldList, mustTermFilter);

			}
		

		} catch (Exception e) {
			logger.error("Error in getResourcedetailsByResourceId ", e);
			throw e;
		}

		return resourceDetails;
	}

	/**
	 * Gets the vulnerability summary.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param reqSeverity
	 *            the req severity
	 * @return the vulnerability summary
	 * @throws ServiceException
	 *             the service exception
	 */
	@SuppressWarnings({ "unchecked" })
	public Map<String, Object> getVulnerabilitySummary(String assetGroup, String reqSeverity) throws ServiceException {

		List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);

		Map<String, Object> vulnerabilitySummary = new HashMap<>();
		List<Map<String, Object>> severityInfo = new ArrayList<>();
		if (vulnTargetTypes.isEmpty()) {
			for (int i = 3; i <= 5; i++) {
				Map<String, Object> sevInfo = new HashMap<>();
				sevInfo.put(SEVERITY, "S" + i);
				sevInfo.put(SEVEITY_LEVEL, i);
				sevInfo.put(COUNT, 0);
				sevInfo.put("appCount", 0);
				sevInfo.put("hostCount", 0);
				sevInfo.put(UNIQUE_VULN_COUNT, 0);
				sevInfo.put(VULN_COUNT, 0);
				severityInfo.add(sevInfo);
			}
			vulnerabilitySummary.put(SEV_INFO, severityInfo);
			vulnerabilitySummary.put(VULNEREBILITIES, 0);
			vulnerabilitySummary.put("hosts", 0);
			vulnerabilitySummary.put(TOTAL_VULN_ASSETS, 0);
			vulnerabilitySummary.put("compliantpercent", 100);
			vulnerabilitySummary.put("assetsWithVulns", 0);
			return vulnerabilitySummary;

		} else {

			Map<String, Map<String, Object>> queryResults = new HashMap<>();

			long totalQualysCount = 0;
			long vulnerableAssetCount = 0;
			long totalAssetCount = 0;

			ExecutorService executor = Executors.newFixedThreadPool(3);
			executor.execute(() -> {
				queryResults.put("uniqueHost", vulnerabilityRepository.getUniqueHost(assetGroup, reqSeverity));
			});
			executor.execute(() -> {
				queryResults.put("VulnInfo", vulnerabilityRepository.getVulnInfo(assetGroup, reqSeverity));

			});
			executor.execute(() -> {
				queryResults.put("uniqueApp", vulnerabilityRepository.getUniqueApp(assetGroup));
			});
			executor.shutdown();
			while (!executor.isTerminated()) {
			}

			Map<String, Object> uniqueHost = queryResults.get("uniqueHost");
			Map<String, Object> vulnInfo = queryResults.get("VulnInfo");
			Map<String, Object> uniqueApp = queryResults.get("uniqueApp");

			List<String> sevList = Arrays.asList(reqSeverity.split(","));
			List<String> summarySevList = Arrays.asList(vulnSummarySeverity.split(","));
			Map<String, Object> sevVulnInfo;
			Map<String, Object> vulnInfoMap;

			List<Map<String, Object>> sevVulnfoList = new ArrayList<>();
			vulnerabilitySummary.put(SEV_INFO, sevVulnfoList);

			for (String sev : sevList) {
				sevVulnInfo = new HashMap<>();
				sevVulnInfo.put(SEVEITY_LEVEL, Integer.valueOf(sev));
				sevVulnInfo.put(SEVERITY, "S" + sev);
				sevVulnInfo.put("hostCount", uniqueHost.get(sev) == null ? 0 : uniqueHost.get(sev));
				if (summarySevList.contains(sev)) {
					vulnerableAssetCount += Long.valueOf(sevVulnInfo.get("hostCount").toString());
				}
				vulnInfoMap = (Map<String, Object>) vulnInfo.get(sev);
				if (vulnInfoMap != null) {
					sevVulnInfo.put(COUNT, vulnInfoMap.get(VULN_COUNT));
					sevVulnInfo.put(VULN_COUNT, vulnInfoMap.get(VULN_COUNT));
					sevVulnInfo.put(UNIQUE_VULN_COUNT, vulnInfoMap.get(UNIQUE_VULN_COUNT));
				} else {
					sevVulnInfo.put(COUNT, 0);
					sevVulnInfo.put(VULN_COUNT, 0);
					sevVulnInfo.put(UNIQUE_VULN_COUNT, 0);
				}
				sevVulnInfo.put("appCount", uniqueApp.get(sev) == null ? 0 : uniqueApp.get(sev));
				sevVulnfoList.add(sevVulnInfo);
			}
			vulnerabilitySummary.put(UNIQUE_VULN_COUNT, sevVulnfoList.stream()
					.mapToLong(sevData -> Long.valueOf(sevData.get(UNIQUE_VULN_COUNT).toString())).sum());
			vulnerabilitySummary.put("assetsWithVulns", uniqueHost.get(TOTAL) == null ? 0 : uniqueHost.get(TOTAL));
			vulnerabilitySummary.put(VULNEREBILITIES, vulnInfo.get(TOTAL) == null ? 0 : vulnInfo.get(TOTAL));

			if (sevList.stream().filter(summarySevList::contains).count() != summarySevList.size()) {
				vulnerableAssetCount = Long.valueOf(
						vulnerabilityRepository.getUniqueHost(assetGroup, vulnSummarySeverity).get(TOTAL).toString());
			}

			for (String vulnType : vulnTargetTypes) {
				try {
					if (vulnType.equals(ONPREMSERVER)) {

						AssetCount totalAssets = assetServiceClient.getTotalAssetsCount(assetGroup, vulnType, null);
						AssetCountData data = totalAssets.getData();
						AssetCountByAppEnvDTO[] assetcount = data.getAssetcount();
						Long totalAssetsCount = 0l;
						for (AssetCountByAppEnvDTO assetCount_Count : assetcount) {
							if (assetCount_Count.getType().equalsIgnoreCase(vulnType)) {
								totalAssetsCount = Long.parseLong(assetCount_Count.getCount());
							}
						}
						totalAssetCount += totalAssetsCount;
						totalQualysCount += vulnerabilityRepository.getTotalQualysHostCount(assetGroup, vulnType);

					} else {
						Request request = new Request();
						request.setAg(assetGroup);
						Map<String, String> filter = new HashMap<>();
						filter.put("domain", "Infra & Platforms");
						if (vulnType.equals(EC2)) {
							filter.put("ruleId.keyword", EC2_QUALYS_RULEID);
						}

						if (vulnType.equals(VIRTUALMACHINE)) {
							filter.put("ruleId.keyword", VIRTUALMACHINE_QUALYS_RULEID);
						}

						request.setFilter(filter);
						// Commenting the old code
						// Map<String, Object> response =
						// complianceService.getRulecompliance(request).getResponse().get(0);
						// new code starts

						List<LinkedHashMap<String, Object>> responses = new ArrayList<>();
						Map<String, Object> response = new HashMap<>();
						ResponseEntity<Object> nonCompliancePolicyRuleresponse = complianceServiceClient
								.getNonCompliancePolicyByRule(request);
						if (nonCompliancePolicyRuleresponse != null) {
							Map<String, Object> responseBody = (Map<String, Object>) nonCompliancePolicyRuleresponse
									.getBody();
							Map<String, Object> dataResponseMap = (Map<String, Object>) responseBody.get("data");
							responses = (List<LinkedHashMap<String, Object>>) dataResponseMap.get("response");
							if (responses.size() > 0) {
								response = responses.get(0);
								// new code ends
								totalAssetCount += Long.valueOf(response.get("assetsScanned").toString());
								totalQualysCount += Long.valueOf(response.get("passed").toString());
							}
						}
					}
				}
				// catch(ServiceException | DataException e){
				catch (DataException e) {
					throw new ServiceException();
				}
			}

			try {

				vulnerabilitySummary.put("hosts", totalAssetCount);
				if (totalQualysCount > totalAssetCount) {
					totalQualysCount = totalAssetCount;
				}

				long totalVulnerableAssets = totalAssetCount - totalQualysCount + vulnerableAssetCount;
				if (totalVulnerableAssets > totalAssetCount) {
					totalVulnerableAssets = totalAssetCount;
				}
				vulnerabilitySummary.put(TOTAL_VULN_ASSETS, totalVulnerableAssets);

				float compliantCount = (float) totalAssetCount - totalVulnerableAssets;
				float compliantpercent = 100;
				if (totalAssetCount > 0) {
					compliantpercent = (compliantCount / totalAssetCount) * 100;
				}
				DecimalFormat df = new DecimalFormat("#.00");
				vulnerabilitySummary.put("compliantpercent", Math.floor(Float.valueOf(df.format(compliantpercent))));
				vulnerabilitySummary.put("hostsScanned", totalQualysCount);
				vulnerabilitySummary.put("hostsNotScanned", totalAssetCount - totalQualysCount);
				if (totalAssetCount > 0) {
					vulnerabilitySummary.put("hostsScanCoverage",
							Math.floor((1.0 * totalQualysCount / totalAssetCount) * 100));
				} else {
					vulnerabilitySummary.put("hostsScanCoverage", 0);
				}
			} catch (Exception e) {
				logger.error(e);
				throw new ServiceException(e);
			}
			if (vulnerabilitySummary.isEmpty()) {
				throw new ServiceException(NO_DATA_FOUND);
			}
			return vulnerabilitySummary;
		}

	}

	/**
	 * Gets the vulnerability by app and env.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param filter
	 *            the filter
	 * @param application
	 *            the application
	 * @return the vulnerability by app and env
	 * @throws Exception
	 *             the exception
	 */
	public List<Map<String, Object>> getVulnerabilityByAppAndEnv(String assetGroup, String filter, String application)
			throws Exception {

		List<Map<String, Object>> vulnApplications = new ArrayList<>();
		List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);

		if (!vulnTargetTypes.isEmpty()) {
			for (String parentType : vulnTargetTypes) {
				vulnApplications.addAll(vulnerabilityRepository.getVulnerabilyAcrossAppAndEnv(assetGroup, filter,
						application, parentType, null));
			}
		}

		return vulnApplications;
	}

	/**
	 * Gets the vulnerability trend.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param filter
	 *            the filter
	 * @param from
	 *            the from
	 * @param to
	 *            the to
	 * @return the vulnerability trend
	 * @throws Exception
	 *             the exception
	 */
	public List<Map<String, Object>> getVulnerabilityTrend(String assetGroup, Map<String, String> filter, Date from,
			Date to) throws Exception {
		return vulnerabilityRepository.getVulnerabilityTrend(assetGroup, filter, from, to);
	}

	/**
	 * Gets the vulnerability trend.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severity
	 *            the severity
	 * @param from
	 *            the from
	 * @return the vulnerability trend with open new count
	 * @throws Exception
	 *             the exception
	 */
	public List<Map<String, Object>> getVulnerabilityNewOpenTrend(String assetGroup, String severity, Date from)
			throws Exception {
		return vulnTrendGenerator.generateTrend(assetGroup, severity, from);
	}

	/**
	 * Gets the vulnerabilities distribution.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @return the vulnerabilities distribution
	 * @throws Exception
	 *             the exception
	 */
	public List<Map<String, Object>> getVulnerabilitiesDistribution(String assetGroup) throws Exception {

		List<Map<String, Object>> vulnDistributions = new ArrayList<>();
		List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
		if (!vulnTargetTypes.isEmpty()) {
			for (String parentType : vulnTargetTypes) {
				vulnDistributions
						.addAll(vulnerabilityRepository.getVulnerabilitiesDistribution(assetGroup, parentType));
			}
		}
		return vulnDistributions;
	}

	/**
	 * Filter matching collection elements.
	 *
	 * @param masterDetailList
	 *            the master detail list
	 * @param searchText
	 *            the search text
	 * @param b
	 *            the b
	 * @return the object
	 * @throws ServiceException
	 *             the ServiceException
	 */
	public Object filterMatchingCollectionElements(List<Map<String, Object>> masterDetailList, String searchText,
			boolean b) throws ServiceException {
		return CommonUtils.filterMatchingCollectionElements(masterDetailList, searchText, true);
	}

	/**
	 * Gets the vulnerabilitysummary by resource id.
	 *
	 * @param instanceId
	 *            the instance id
	 * @return the vulnerabilitysummary by resource id
	 */
	public Map<String, Object> getVulnerabilitysummaryByResourceId(String instanceId) {
		return vulnerabilityRepository.getVulnerabilitysummaryByResourceId(instanceId);
	}

	/**
	 * Gets the vulnerability details by resource id.
	 *
	 * @param instanceId
	 *            the instance id
	 * @return the vulnerability details by resource id
	 */
	public List<Map<String, Object>> getVulnerabilityDetailsByResourceId(String instanceId) {

		List<Map<String, Object>> vulnerabilitiesDetails = new ArrayList<>();
		try {
			List<Map<String, Object>> vulnerabilitiesDetailsList = vulnerabilityRepository
					.getVulnerabilityDetailsByResourceId(instanceId);
			vulnerabilitiesDetails = formVulnerabilitiesData(vulnerabilitiesDetailsList, new HashMap<String, Long>());
		} catch (Exception e) {
			logger.error("Error in getVulnerabilitiesDetails ", e);
			throw e;
		}

		return vulnerabilitiesDetails;
	}

	/**
	 * Form vulnerabilities data.
	 *
	 * @param vulnerabilitiesDetails
	 *            the vulnerabilities details
	 * @param vulnAssetsAffected
	 *            the vuln assets affected
	 * @return the list
	 */
	private List<Map<String, Object>> formVulnerabilitiesData(List<Map<String, Object>> vulnerabilitiesDetails,
			Map<String, Long> vulnAssetsAffected) {

		List<Map<String, Object>> vulnerabilitiesDetailsList = new ArrayList<>();

		vulnerabilitiesDetails.parallelStream().forEach(vulnObject -> {
			Map<String, Object> vulnObj = new LinkedHashMap<>();
			vulnObj.put(TITLE, vulnObject.get(TITLE).toString());
			vulnObj.put(SEVERITY, "S" + Double.valueOf(vulnObject.get(SEVEITY_LEVEL).toString()).intValue());
			if (!CollectionUtils.isEmpty(vulnAssetsAffected)) {
				vulnObj.put(ASSETS_AFFECTED, vulnAssetsAffected.get(String.valueOf(vulnObject.get("qid").toString())));
			}
			vulnObj.put("qid", Double.valueOf(vulnObject.get("qid").toString()).longValue());
			vulnObj.put(CATEGORY, vulnObject.get(CATEGORY).toString());
			vulnObj.put(VULN_TYPE, vulnObject.get(VULN_TYPE).toString());
			if (vulnObject.containsKey(PATCHABLE)) {
				vulnObj.put(PATCHABLE, "1".equals(vulnObject.get(PATCHABLE).toString()) ? true : false);
			}
			vulnObj.put(SEVEITY_LEVEL, Double.valueOf(vulnObject.get(SEVEITY_LEVEL).toString()).intValue());
			synchronized (vulnerabilitiesDetailsList) {
				vulnerabilitiesDetailsList.add(vulnObj);
			}
		});

		if (!CollectionUtils.isEmpty(vulnAssetsAffected)) {
			return vulnerabilitiesDetailsList.stream()
					.sorted((h1,
							h2) -> (int) (Double.parseDouble(h2.get(ASSETS_AFFECTED).toString())
									- (Double.parseDouble(h1.get(ASSETS_AFFECTED).toString()))))
					.sorted((h1,
							h2) -> (int) (Double.parseDouble(h2.get(SEVEITY_LEVEL).toString())
									- (Double.parseDouble(h1.get(SEVEITY_LEVEL).toString()))))
					.collect(Collectors.toList());
		} else {
			return vulnerabilitiesDetailsList.stream()
					.sorted((h1,
							h2) -> (int) (Double.parseDouble(h2.get(SEVEITY_LEVEL).toString())
									- (Double.parseDouble(h1.get(SEVEITY_LEVEL).toString()))))
					.collect(Collectors.toList());
		}

	}

	/**
	 * Gets the target types.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @return the target types
	 */
	private String getTargetTypes(String assetGroup) {
		String tTypesTemp;
		String ttypes = null;
		AssetApi assetApi = assetServiceClient.getTargetTypeList(assetGroup, null);
		AssetApiData data = assetApi.getData();
		AssetCountDTO[] targetTypes = data.getTargettypes();
		for (AssetCountDTO name : targetTypes) {
			if (!Strings.isNullOrEmpty(name.getType())) {
				tTypesTemp = new StringBuilder().append('\'').append(name.getType()).append('\'').toString();
				if (Strings.isNullOrEmpty(ttypes)) {
					ttypes = tTypesTemp;
				} else {
					ttypes = new StringBuilder(ttypes).append(",").append(tTypesTemp).toString();
				}
			}
		}
		return ttypes;
	}

	/**
	 * Gets the aging summary.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @return the aging summary
	 */
	public List<Map<String, Object>> getAgingSummary(String assetGroup) {
		return vulnerabilityRepository.getAgingSummary(assetGroup);
	}

	/**
	 * Gets the vulnerability by qid.
	 *
	 * @param qid
	 *            the qid
	 * @return the vulnerability by qid
	 */
	public List<Map<String, Object>> getVulnerabilityByQid(String qid) {

		List<Map<String, Object>> vulnByCategories = new ArrayList<>();
		Map<String, Object> vulnKbData = vulnerabilityRepository.getVulnerabilityByQid(qid);
		vulnByCategories.add(formGeneralCategory(vulnKbData));
		vulnByCategories.add(formDetailsCategory(vulnKbData));
		vulnByCategories.add(formSoftwareCategory(vulnKbData));
		vulnByCategories.add(formImpactCategory(vulnKbData));
		vulnByCategories.add(formThreatCategory(vulnKbData));
		vulnByCategories.add(formSolutionCategory(vulnKbData));
		vulnByCategories.add(formExploitabilityCategory(vulnKbData));
		vulnByCategories.add(formAssociatedMalware(vulnKbData));
		return vulnByCategories;
	}

	/**
	 * Form general category.
	 *
	 * @param vulnKbData
	 *            the vuln kb data
	 * @return the map
	 */
	@SuppressWarnings("unchecked")
	private Map<String, Object> formGeneralCategory(Map<String, Object> vulnKbData) {

		ObjectMapper oMapper = new ObjectMapper();

		Map<String, Object> category = new LinkedHashMap<>();
		category.put("name", "General Information");
		Map<String, Object> attributes = new LinkedHashMap<>();
		attributes.put("QID", null == vulnKbData.get("qid") ? "" : vulnKbData.get("qid"));
		attributes.put("Title", null == vulnKbData.get(TITLE) ? "" : vulnKbData.get(TITLE));
		attributes.put("Severity Level", null == vulnKbData.get(SEVEITY_LEVEL) ? "" : vulnKbData.get(SEVEITY_LEVEL));
		attributes.put("Vulnerability Type", null == vulnKbData.get(VULN_TYPE) ? "" : vulnKbData.get(VULN_TYPE));
		attributes.put("Category", null == vulnKbData.get(CATEGORY) ? "" : vulnKbData.get(CATEGORY));

		Map<String, Object> discovery = oMapper.convertValue(vulnKbData.get("discovery"), Map.class);

		if (discovery != null) {
			attributes.put("Authentication", fetchAttributes(discovery, "authtypelist", "authtype", true));
		}

		attributes.put("Service Modified", null == vulnKbData.get("lastservicemodificationdatetime") ? ""
				: vulnKbData.get("lastservicemodificationdatetime"));
		attributes.put("Published",
				null == vulnKbData.get("publisheddatetime") ? "" : vulnKbData.get("publisheddatetime"));

		category.put(ATTRIBUTES, attributes);
		return category;
	}

	/**
	 * Form details category.
	 *
	 * @param vulnKbData
	 *            the vuln kb data
	 * @return the map
	 */
	@SuppressWarnings("unchecked")
	private Map<String, Object> formDetailsCategory(Map<String, Object> vulnKbData) {
		ObjectMapper oMapper = new ObjectMapper();
		Map<String, Object> category = new HashMap<>();
		category.put("name", "Details");
		Map<String, Object> attributes = new LinkedHashMap<>();
		if (Arrays
				.asList(fetchAttributes(vulnKbData, "discovery", "additionalinfo", false).toString().split("\\s*,\\s*"))
				.contains("Patch Available")) {
			attributes.put("Patch Availble", "Yes");
		} else
			attributes.put("Patch Availble", "No");

		attributes.put("CVE ID", fetchAttributes(vulnKbData, "cvelist", "cve", true));
		attributes.put("Vendor Reference", fetchAttributes(vulnKbData, "vendorreferencelist", "vendorreference", true));
		attributes.put("Bugtraq ID", fetchAttributes(vulnKbData, "bugtraqlist", "bugtraq", true));

		if (null != vulnKbData.get("pciflag")) {
			attributes.put("PCI Flag", Double.valueOf(vulnKbData.get("pciflag").toString()) == 0 ? false : true);
		}

		attributes.put("PCI Reasons", fetchAttributes(vulnKbData, "pcireasons", "pcireason", true));
		if (null != vulnKbData.get("supportedmodules")) {
			attributes.put("Supported Modules", vulnKbData.get("supportedmodules"));
		}

		Map<String, Object> cvss = oMapper.convertValue(vulnKbData.get("cvss"), Map.class);
		Map<String, Object> cvss3 = oMapper.convertValue(vulnKbData.get("cvssv3"), Map.class);
		if (cvss != null) {
			attributes.put("CVSS Base", cvss.get("base"));
			attributes.put("CVSS Temporal", cvss.get("temporal"));
			attributes.put("CVSS Access Vector", fetchAttributes(cvss, "access", "vector", false));
		}
		if (cvss3 != null) {
			attributes.put("CVSS3 Base", cvss3.get("base"));
			attributes.put("CVSS3 Temporal", cvss3.get("temporal"));
		}

		category.put(ATTRIBUTES, attributes);
		return category;
	}

	/**
	 * Form software category.
	 *
	 * @param vulnKbData
	 *            the vuln kb data
	 * @return the map
	 */
	private Map<String, Object> formSoftwareCategory(Map<String, Object> vulnKbData) {

		Map<String, Object> category = new HashMap<>();
		category.put("name", "Software");
		category.put(ATTRIBUTES, fetchAttributes(vulnKbData, "softwarelist", "software", true));
		return category;
	}

	/**
	 * Form threat category.
	 *
	 * @param vulnKbData
	 *            the vuln kb data
	 * @return the map
	 */
	private Map<String, Object> formThreatCategory(Map<String, Object> vulnKbData) {

		Map<String, Object> category = new HashMap<>();
		category.put("name", "Threat");
		category.put(ATTRIBUTES, null == vulnKbData.get("diagnosis") ? "" : vulnKbData.get("diagnosis"));
		return category;
	}

	/**
	 * Form impact category.
	 *
	 * @param vulnKbData
	 *            the vuln kb data
	 * @return the map
	 */
	private Map<String, Object> formImpactCategory(Map<String, Object> vulnKbData) {

		Map<String, Object> category = new HashMap<>();
		category.put("name", "Impact");
		category.put(ATTRIBUTES, null == vulnKbData.get("consequence") ? "" : vulnKbData.get("consequence"));
		return category;
	}

	/**
	 * Form solution category.
	 *
	 * @param vulnKbData
	 *            the vuln kb data
	 * @return the map
	 */
	private Map<String, Object> formSolutionCategory(Map<String, Object> vulnKbData) {

		Map<String, Object> category = new HashMap<>();
		category.put("name", "Solution");
		category.put(ATTRIBUTES, null == vulnKbData.get("solution") ? "" : vulnKbData.get("solution"));
		return category;
	}

	/**
	 * Form exploitability category.
	 *
	 * @param vulnKbData
	 *            the vuln kb data
	 * @return the map
	 */
	@SuppressWarnings("unchecked")
	private Map<String, Object> formExploitabilityCategory(Map<String, Object> vulnKbData) {

		ObjectMapper oMapper = new ObjectMapper();
		List<Map<String, Object>> attributes = new ArrayList<>();
		Map<String, Object> category = new HashMap<>();
		category.put("name", "Exploitability");

		Map<String, Object> correlation = oMapper.convertValue(vulnKbData.get("correlation"), Map.class);
		if (correlation != null && !correlation.isEmpty()) {
			List<Map<String, Object>> exploits = (List<Map<String, Object>>) fetchAttributes(correlation, "exploits",
					"expltsrc", true);
			for (Map<String, Object> exploitTemp : exploits) {
				Map<String, Object> exploit = new HashMap<>();
				exploit.put(SRC_NAME, exploitTemp.get(SRC_NAME));
				exploit.put("exploits", fetchAttributes(exploitTemp, "expltlist", "explt", true));
				attributes.add(exploit);
			}
		}
		category.put(ATTRIBUTES, attributes);
		return category;
	}

	/**
	 * Form associated malware.
	 *
	 * @param vulnKbData
	 *            the vuln kb data
	 * @return the map
	 */
	@SuppressWarnings("unchecked")
	private Map<String, Object> formAssociatedMalware(Map<String, Object> vulnKbData) {
		ObjectMapper oMapper = new ObjectMapper();
		List<Map<String, Object>> attributes = new ArrayList<>();
		Map<String, Object> category = new HashMap<>();
		category.put("name", "Malware");

		Map<String, Object> correlation = oMapper.convertValue(vulnKbData.get("correlation"), Map.class);
		if (correlation != null && !correlation.isEmpty()) {
			List<Map<String, Object>> exploits = (List<Map<String, Object>>) fetchAttributes(correlation, "malware",
					"mwsrc", true);
			for (Map<String, Object> exploitTemp : exploits) {
				Map<String, Object> exploit = new HashMap<>();
				exploit.put(SRC_NAME, exploitTemp.get(SRC_NAME));
				exploit.put("malwares", fetchAttributes(exploitTemp, "mwlist", "mwinfo", true));
				attributes.add(exploit);
			}
		}
		category.put(ATTRIBUTES, attributes);
		return category;
	}

	/**
	 * Fetch attributes.
	 *
	 * @param vulnKbData
	 *            the vuln kb data
	 * @param parent
	 *            the parent
	 * @param child
	 *            the child
	 * @param isList
	 *            the is list
	 * @return the object
	 */
	@SuppressWarnings("unchecked")
	private Object fetchAttributes(Map<String, Object> vulnKbData, String parent, String child, boolean isList) {
		Map<String, Object> parentMap = new ObjectMapper().convertValue(vulnKbData.get(parent), Map.class);
		Object childObj;
		if (parentMap != null) {
			childObj = parentMap.get(child);
			if (childObj != null)
				return childObj;
		}

		if (isList) {
			return new ArrayList<>();
		} else {
			return "";
		}
	}


	/**
	 * Gets the highest lowest performers.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severity
	 *            the severity
	 * @param type
	 *            the type
	 * @return the highest lowest performers
	 */
	@SuppressWarnings("unchecked")
	public Map<String, Integer> getHighestLowestPerformers(String assetGroup, String severity, String type) {

		String mngtLevel2 = "2";
		String mngtLevel3 = "3";
		String mngtLevel4 = "4";
		String mngtLevel5 = "5";
		String mngtLevel6 = "6";
		String mngtLevel7 = "7";

		Map<String, Long> appDetails = new HashMap<>();
		List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);

		if (StringUtils.isBlank(severity)) {
			severity = SEVERITY_LEVELS;
		}
		Map<String, Integer> perfData = new HashMap<>();

		if ("org".equalsIgnoreCase(type)) {
			if (!vulnTargetTypes.isEmpty()) {
				for (String parentType : vulnTargetTypes) {
					try {
						Map<String, Long> appDetailsTemp = vulnerabilityRepository.getAppsBySeverity(assetGroup,
								parentType, severity);
						if (appDetails.isEmpty()) {
							appDetails = new HashMap<>(appDetailsTemp);
						} else {
							for (Entry<String, Long> appDetailTemp : appDetailsTemp.entrySet()) {
								boolean appExists = false;
								for (Entry<String, Long> appDetail : appDetails.entrySet()) {
									if (appDetail.getKey().equals(appDetailTemp.getKey())) {
										appDetails.put(appDetail.getKey(),
												appDetail.getValue() + appDetailTemp.getValue());
										appExists = true;
										break;
									}
								}
								if (!appExists) {
									appDetails.put(appDetailTemp.getKey(), appDetailTemp.getValue());
								}
							}
						}
					} catch (Exception e) {
						logger.error("Exception in getHighestLowestPeformers org", e);
					}
				}
			}
			try {
				Map<String, Map<String, List<String>>> directorsInfo = getDirectorsForAG(appDetails.keySet());
				if (directorsInfo.get(mngtLevel2) != null && directorsInfo.get(mngtLevel2).size() > 1) {
					formPerformersData(appDetails, perfData, directorsInfo.get(mngtLevel2));
				} else if (directorsInfo.get(mngtLevel3) != null && directorsInfo.get(mngtLevel3).size() > 1) {
					formPerformersData(appDetails, perfData, directorsInfo.get(mngtLevel3));
				} else if (directorsInfo.get(mngtLevel4) != null && directorsInfo.get(mngtLevel4).size() > 1) {
					formPerformersData(appDetails, perfData, directorsInfo.get(mngtLevel4));
				} else {
					Map<String, List<String>> directorLevel5Above = new HashMap<>();
					if (directorsInfo.get(mngtLevel5) != null) {
						directorLevel5Above.putAll(directorsInfo.get(mngtLevel5));
					}
					if (directorsInfo.get(mngtLevel6) != null) {
						directorLevel5Above.putAll(directorsInfo.get(mngtLevel6));
					}
					if (directorsInfo.get(mngtLevel7) != null) {
						directorLevel5Above.putAll(directorsInfo.get(mngtLevel7));
					}
					formPerformersData(appDetails, perfData, directorLevel5Above);
				}
			} catch (Exception e) {
				logger.error("Exception in getHighestLowestPeformers org", e);
			}
		} else if (APPLICATION.equalsIgnoreCase(type)) {
			try {
				List<Map<String, Object>> vulnApplications = getVulnerabilityByAppAndEnv(assetGroup, TAGS_APPS, "");
				for (Map<String, Object> appInfo : vulnApplications) {
					String app = appInfo.get(APPS).toString();
					List<Map<String, Object>> sevInfo = (List<Map<String, Object>>) appInfo.get(SEV_INFO);
					perfData.put(app, getVulnInstanceCount(sevInfo, severity));
				}
			} catch (Exception e) {
				logger.error("Exception in getHighestLowestPeformers app", e);
			}

		} else if (ENVIRONMENT.equalsIgnoreCase(type)) {

			try {
				List<Map<String, Object>> vulnEnvmnts = getVulnerabilityByAppAndEnv(assetGroup, TAGS_ENV, "");
				for (Map<String, Object> envInfo : vulnEnvmnts) {
					String env = envInfo.get(ENV).toString();
					List<Map<String, Object>> sevInfo = (List<Map<String, Object>>) envInfo.get(SEV_INFO);
					perfData.put(env, getVulnInstanceCount(sevInfo, severity));
				}
			} catch (Exception e) {
				logger.error("Exception in getHighestLowestPeformers env", e);
			}
		}
		return perfData.entrySet().stream().sorted(Map.Entry.comparingByValue()).collect(Collectors
				.toMap(Map.Entry::getKey, Map.Entry::getValue, (oldValue, newValue) -> oldValue, LinkedHashMap::new));
	}

	/**
	 * Gets the vuln instance count.
	 *
	 * @param sevInfoList
	 *            the sev info list
	 * @param severity
	 *            the severity
	 * @return the vuln instance count
	 */
	private int getVulnInstanceCount(List<Map<String, Object>> sevInfoList, String severity) {
		List<String> sevList = Arrays.asList(severity.split(","));
		return sevInfoList.stream().filter(sevInfo -> sevList.contains(sevInfo.get("severitylevel").toString()))
				.mapToInt(sevInfo -> Double.valueOf(sevInfo.get("vulnInstanceCount").toString()).intValue()).sum();
	}

	/**
	 * Gets the vuln target types.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @return the vuln target types
	 */
	private List<String> getVulnTargetTypes(String assetGroup) {

		String validTargetTypes = getTargetTypes(assetGroup);
		List<String> vulnTargetTypes = new ArrayList<>();
		for (String vulnType : vulnTypes.split(",")) {
			if (!StringUtils.isEmpty(validTargetTypes) && validTargetTypes.contains(vulnType.trim())) {
				vulnTargetTypes.add(vulnType);
			}
		}
		return vulnTargetTypes;
	}

	/**
	 * Gets the distribution summary by infra type.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severity
	 *            the severity
	 * @return the distribution summary by infra type
	 * @throws ServiceException
	 *             the service exception
	 */
	public List<Map<String, Object>> getDistributionSummaryByInfraType(String assetGroup, String severity)
			throws ServiceException {

		List<Map<String, Object>> distributionList = new ArrayList<>();

		List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
		if (StringUtils.isBlank(severity)) {
			severity = SEVERITY_LEVELS;
		}
		long totalVulnCount = 0;
		for (String vulnType : vulnTargetTypes) {
			Map<String, Object> info = new HashMap<>();
			try {
				info = vulnerabilityRepository.getDistributionSummaryByInfraType(assetGroup, severity, vulnType);
			} catch (Exception e) {
				logger.error("Error in getDistributionSummaryByInfraType ", e);
				throw new ServiceException();
			}

			totalVulnCount += Long.valueOf(info.get(VULNEREBILITIES).toString());

			if (vulnType.equals(ONPREMSERVER)) {
				info.put(CATEGORY, "On-Prem");
				distributionList.add(info);
			} else {
				Optional<Map<String, Object>> cloudInfoOptional = distributionList.stream()
						.filter(distro -> distro.get(CATEGORY).equals("Cloud")).findAny();
				if (cloudInfoOptional.isPresent()) {
					Map<String, Object> currentCloudInfo = cloudInfoOptional.get();
					currentCloudInfo.put(TOTAL_VULN_ASSETS,
							Long.valueOf(currentCloudInfo.get(TOTAL_VULN_ASSETS).toString())
									+ Long.valueOf(info.get(TOTAL_VULN_ASSETS).toString()));
					currentCloudInfo.put(VULNEREBILITIES, Long.valueOf(currentCloudInfo.get(VULNEREBILITIES).toString())
							+ Long.valueOf(info.get(VULNEREBILITIES).toString()));
					currentCloudInfo.put(UNIQUE_VULN_COUNT,
							Long.valueOf(currentCloudInfo.get(UNIQUE_VULN_COUNT).toString())
									+ Long.valueOf(info.get(UNIQUE_VULN_COUNT).toString()));
				} else {
					info.put(CATEGORY, "Cloud");
					distributionList.add(info);
				}

			}

		}

		double contribution = HUNDRED;
		for (int i = 0; i < distributionList.size(); i++) {
			Map<String, Object> info = distributionList.get(i);
			double contributionPercent = Math
					.floor((Double.valueOf(info.get(VULNEREBILITIES).toString()) / totalVulnCount) * HUNDRED);
			if (i == distributionList.size() - 1) {
				info.put(CONTRIBUTION, contribution);
			} else {
				info.put(CONTRIBUTION, contributionPercent);
				contribution = contribution - contributionPercent;
			}
		}
		return distributionList;
	}

	/**
	 * Gets the distribution summary by env.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severity
	 *            the severity
	 * @return the distribution summary by env
	 * @throws ServiceException
	 *             the service exception
	 */
	public List<Map<String, Object>> getDistributionSummaryByEnv(String assetGroup, String severity)
			throws ServiceException {

		List<Map<String, Object>> distributionList = new ArrayList<>();
		if (StringUtils.isBlank(severity)) {
			severity = SEVERITY_LEVELS;
		}

		long totalVulnCount = 0;

		Map<String, Object> prodInfo = new HashMap<>();
		prodInfo.put(TOTAL_VULN_ASSETS, 0);
		prodInfo.put(VULNEREBILITIES, 0);
		prodInfo.put(UNIQUE_VULN_COUNT, 0);

		Map<String, Object> nonProdInfo = new HashMap<>();
		nonProdInfo.put(TOTAL_VULN_ASSETS, 0);
		nonProdInfo.put(VULNEREBILITIES, 0);
		nonProdInfo.put(UNIQUE_VULN_COUNT, 0);
		try {
			Map<String, Long> prodInfoTemp = vulnerabilityRepository.getProdInfoByEnv(assetGroup, severity);
			Map<String, Long> nonProdInfoTemp = vulnerabilityRepository.getNonProdInfoByEnv(assetGroup, severity);

			totalVulnCount += prodInfoTemp.get(VULNEREBILITIES) + nonProdInfoTemp.get(VULNEREBILITIES);

			for (Entry<String, Object> entry : prodInfo.entrySet()) {
				prodInfo.put(entry.getKey(),
						Long.valueOf(entry.getValue().toString()) + prodInfoTemp.get(entry.getKey()));
			}

			for (Entry<String, Object> entry : nonProdInfo.entrySet()) {
				nonProdInfo.put(entry.getKey(),
						Long.valueOf(entry.getValue().toString()) + nonProdInfoTemp.get(entry.getKey()));
			}
		} catch (Exception e) {
			throw new ServiceException(e);
		}
		prodInfo.put(CATEGORY, "Prod");
		distributionList.add(prodInfo);
		nonProdInfo.put(CATEGORY, "Non-Prod");
		distributionList.add(nonProdInfo);

		double contribution = HUNDRED;
		for (int i = 0; i < distributionList.size(); i++) {
			Map<String, Object> info = distributionList.get(i);
			if (totalVulnCount > 0) {
				double contributionPercent = Math
						.floor((Double.valueOf(info.get(VULNEREBILITIES).toString()) / totalVulnCount) * HUNDRED);
				if (i == distributionList.size() - 1) {
					info.put(CONTRIBUTION, contribution);
				} else {
					info.put(CONTRIBUTION, contributionPercent);
					contribution = contribution - contributionPercent;
				}
			} else {
				info.put(CONTRIBUTION, 0);
			}
		}
		return distributionList;
	}

	/**
	 * Gets the distribution summary by vuln type.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severity
	 *            the severity
	 * @return the distribution summary by vuln type
	 * @throws DataException
	 *             the data exception
	 */
	public List<Map<String, Object>> getDistributionSummaryByVulnType(String assetGroup, String severity)
			throws DataException {
		if (StringUtils.isBlank(severity)) {
			severity = SEVERITY_LEVELS;
		}
		return vulnerabilityRepository.getDistributionSummaryByVulnType(assetGroup, severity);
	}

	/**
	 * Gets the remediation actions summary.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severity
	 *            the severity
	 * @return the remediation actions summary
	 * @throws DataException
	 *             the data exception
	 */
	public List<Map<String, Object>> getRemediationActionsSummary(String assetGroup, String severity)
			throws DataException {

		List<Map<String, Object>> remediationList = new ArrayList<>();
		if (StringUtils.isBlank(severity)) {
			severity = SEVERITY_LEVELS;
		}

		List<Map<String, Object>> eolActions = vulnerabilityRepository
				.getDataFromPacmanRDS("SELECT matchingString,subAction FROM cf_RemediationCriteria WHERE "
						+ "action='Remove/Replace EOL Software'");
		List<Map<String, Object>> stopRemoveActions = vulnerabilityRepository
				.getDataFromPacmanRDS("SELECT matchingString,subAction FROM cf_RemediationCriteria WHERE "
						+ "action='Stop Service/Remove Software'");
		List<Map<String, Object>> swConfigChangeActions = vulnerabilityRepository
				.getDataFromPacmanRDS("SELECT matchingString,subAction FROM cf_RemediationCriteria WHERE "
						+ "action='Software Configuration Change'");
		List<Map<String, Object>> swUpdateActions = vulnerabilityRepository.getDataFromPacmanRDS(
				"SELECT matchingString,subAction FROM cf_RemediationCriteria WHERE " + "action='Software Update'");

		String softwareConfig = getAllMatchingString(swConfigChangeActions);
		String softwareUpdate = getAllMatchingString(swUpdateActions);

		Map<String, Object> osPatching = new HashMap<>();
		osPatching.put(ACTION, "OS Patching");
		osPatching.put(DESCRIPTION, "Apply the patches released by the operating system provider");
		osPatching.put(CONTRIBUTION, 0);
		Map<String, Object> eolSoftware = new HashMap<>();
		eolSoftware.put(ACTION, "Remove/Replace EOL Software");
		eolSoftware.put(CONTRIBUTION, 0);
		eolSoftware.put(DESCRIPTION, "Remove or replace below listed End of Life Software versions");
		Map<String, Object> noSolution = new HashMap<>();
		noSolution.put(ACTION, "No Solution Available");
		noSolution.put(CONTRIBUTION, 0);
		noSolution.put(DESCRIPTION, "Vulnerabilities with no published solution yet");
		Map<String, Object> stopRemove = new HashMap<>();
		stopRemove.put(ACTION, "Stop Service/Remove Software");
		stopRemove.put(CONTRIBUTION, 0);
		stopRemove.put(DESCRIPTION, "Stop unimportant vulnerable services, remove malicious softwares from the hosts");
		Map<String, Object> swConfigChange = new HashMap<>();
		swConfigChange.put(ACTION, "Software Configuration Change");
		swConfigChange.put(CONTRIBUTION, 0);
		swConfigChange.put(DESCRIPTION,
				"Fix the configurations of the below listed softwares. Some default configurations like default admin username and password should be replaced with a stronger one");
		Map<String, Object> swUpdate = new HashMap<>();
		swUpdate.put(ACTION, "Software Update");
		swUpdate.put(CONTRIBUTION, 0);
		swUpdate.put(DESCRIPTION,
				"Update the below listed softwares to their latest version or apply patches released by the software provider ");

		List<Map<String, Object>> eolSubActions = new ArrayList<>();
		List<Map<String, Object>> stopRemoveSubActions = new ArrayList<>();
		List<Map<String, Object>> swConfigChangeSubActions = new ArrayList<>();
		List<Map<String, Object>> swUpdateSubActions = new ArrayList<>();

		Map<String, Object> unclassified = new HashMap<>();
		unclassified.put(ACTION, "Unclassified");
		unclassified.put(DESCRIPTION,
				"These vulnerabilities are not classified yet. Refer the vulnerability description to fix the vulnerability");
		unclassified.put(CONTRIBUTION, 0);

		Map<String, Object> qids = vulnerabilityRepository.getAllQidByAG(assetGroup, severity);
		Long total = qids.entrySet().stream().mapToLong(entry -> Long.valueOf(entry.getValue().toString())).sum();
		for (String qidTitleClass : qids.keySet()) {
			String qid = qidTitleClass.split("~")[0];
			String vulnTitle = qidTitleClass.split("~")[1].toLowerCase();
			String classification = qidTitleClass.split("~")[2];
			if ("OS".equalsIgnoreCase(classification)) {
				osPatching.put(CONTRIBUTION, Long.valueOf(osPatching.get(CONTRIBUTION).toString())
						+ Long.valueOf(qids.get(qidTitleClass).toString()));
			} else if (vulnTitle.contains("EOL/Obsolete".toLowerCase())) {
				eolSoftware.put(CONTRIBUTION, Long.valueOf(eolSoftware.get(CONTRIBUTION).toString())
						+ Long.valueOf(qids.get(qidTitleClass).toString()));
				formSubActionList(eolActions, eolSubActions, vulnTitle,
						Long.valueOf(qids.get(qidTitleClass).toString()));
			} else if ("11925".equals(qid) || "370914".equals(qid)) {
				noSolution.put(CONTRIBUTION, Long.valueOf(noSolution.get(CONTRIBUTION).toString())
						+ Long.valueOf(qids.get(qidTitleClass).toString()));
			} else if (vulnTitle.contains("Java Debug Wire Protocol".toLowerCase())) {
				stopRemove.put(CONTRIBUTION, Long.valueOf(stopRemove.get(CONTRIBUTION).toString())
						+ Long.valueOf(qids.get(qidTitleClass).toString()));
				formSubActionList(stopRemoveActions, stopRemoveSubActions, vulnTitle,
						Long.valueOf(qids.get(qidTitleClass).toString()));
			} else if (checkVulnTitle(vulnTitle, softwareConfig)) {
				swConfigChange.put(CONTRIBUTION, Long.valueOf(swConfigChange.get(CONTRIBUTION).toString())
						+ Long.valueOf(qids.get(qidTitleClass).toString()));
				formSubActionList(swConfigChangeActions, swConfigChangeSubActions, vulnTitle,
						Long.valueOf(qids.get(qidTitleClass).toString()));
			} else if (checkVulnTitle(vulnTitle, softwareUpdate)) {
				swUpdate.put(CONTRIBUTION, Long.valueOf(swUpdate.get(CONTRIBUTION).toString())
						+ Long.valueOf(qids.get(qidTitleClass).toString()));
				formSubActionList(swUpdateActions, swUpdateSubActions, vulnTitle,
						Long.valueOf(qids.get(qidTitleClass).toString()));
			} else {
				unclassified.put(CONTRIBUTION, Long.valueOf(unclassified.get(CONTRIBUTION).toString())
						+ Long.valueOf(qids.get(qidTitleClass).toString()));
			}
		}

		calculateContributionPercentage(eolSubActions, Long.valueOf(eolSoftware.get(CONTRIBUTION).toString()));
		calculateContributionPercentage(stopRemoveSubActions, Long.valueOf(stopRemove.get(CONTRIBUTION).toString()));
		calculateContributionPercentage(swConfigChangeSubActions,
				Long.valueOf(swConfigChange.get(CONTRIBUTION).toString()));
		calculateContributionPercentage(swUpdateSubActions, Long.valueOf(swUpdate.get(CONTRIBUTION).toString()));

		eolSoftware.put(SUB_ACTIONS, eolSubActions);
		stopRemove.put(SUB_ACTIONS, stopRemoveSubActions);
		swConfigChange.put(SUB_ACTIONS, swConfigChangeSubActions);
		swUpdate.put(SUB_ACTIONS, swUpdateSubActions);

		remediationList.add(osPatching);
		remediationList.add(eolSoftware);
		remediationList.add(noSolution);
		remediationList.add(stopRemove);
		remediationList.add(swConfigChange);
		remediationList.add(swUpdate);
		remediationList.add(unclassified);

		calculateContributionPercentage(remediationList, total);
		return remediationList;
	}

	/**
	 * Check vuln title.
	 *
	 * @param vulnTitle
	 *            the vuln title
	 * @param values
	 *            the values
	 * @return true, if successful
	 */
	private boolean checkVulnTitle(String vulnTitle, String values) {
		for (String value : values.split(",")) {
			if (vulnTitle.contains(value)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Form sub action list.
	 *
	 * @param actions
	 *            the actions
	 * @param subActions
	 *            the sub actions
	 * @param vulnTitle
	 *            the vuln title
	 * @param contribution
	 *            the contribution
	 */
	private void formSubActionList(List<Map<String, Object>> actions, List<Map<String, Object>> subActions,
			String vulnTitle, long contribution) {
		boolean titleMatched = false;
		for (Map<String, Object> action : actions) {
			if (vulnTitle.contains(action.get(MATCHING_STRING).toString().toLowerCase())) {
				titleMatched = true;
				formSubAction(subActions, action.get("subAction").toString(), action.get(MATCHING_STRING).toString(),
						contribution);
				break;
			}
		}
		if (!titleMatched) {
			formSubAction(subActions, "Others", "Others", contribution);
		}
	}

	/**
	 * Form sub action.
	 *
	 * @param subActions
	 *            the sub actions
	 * @param subActionTitle
	 *            the sub action title
	 * @param subActiondescr
	 *            the sub actiondescr
	 * @param contribution
	 *            the contribution
	 */
	private void formSubAction(List<Map<String, Object>> subActions, String subActionTitle, String subActiondescr,
			Long contribution) {
		if (subActions.isEmpty()) {
			Map<String, Object> subAction = new HashMap<>();
			subAction.put(ACTION, subActionTitle);
			subAction.put(DESCRIPTION, subActiondescr);
			subAction.put(CONTRIBUTION, contribution);
			subActions.add(subAction);
		} else {
			boolean subActionExists = false;
			for (Map<String, Object> subAction : subActions) {
				if (subActionTitle.equals(subAction.get(ACTION).toString())) {
					subActionExists = true;
					subAction.put(CONTRIBUTION, Long.valueOf(subAction.get(CONTRIBUTION).toString()) + contribution);
					break;
				}
			}
			if (!subActionExists) {
				Map<String, Object> subAction = new HashMap<>();
				subAction.put(ACTION, subActionTitle);
				subAction.put(DESCRIPTION, subActiondescr);
				subAction.put(CONTRIBUTION, contribution);
				subActions.add(subAction);
			}
		}
	}

	/**
	 * Gets the all matching string.
	 *
	 * @param actions
	 *            the actions
	 * @return the all matching string
	 */
	private String getAllMatchingString(List<Map<String, Object>> actions) {
		List<String> matchingStrings = new ArrayList<>();
		for (Map<String, Object> action : actions) {
			matchingStrings.add(action.get(MATCHING_STRING).toString().toLowerCase());
		}
		return StringUtils.join(matchingStrings, ",");
	}

	/**
	 * Calculate contribution percentage.
	 *
	 * @param contributionList
	 *            the contribution list
	 * @param total
	 *            the total
	 */
	private void calculateContributionPercentage(List<Map<String, Object>> contributionList, long total) {
		DecimalFormat df = new DecimalFormat("###.##");
		ListIterator<Map<String, Object>> it = contributionList.listIterator();
		String contributionPercent;
		while (it.hasNext()) {
			Map<String, Object> bucket = it.next();
			Long contribution = Long.valueOf(bucket.get(CONTRIBUTION).toString());
			if (contribution == 0) {
				it.remove();
			} else {
				contributionPercent = df.format((contribution * HUNDRED) / total);
				if ("0".equals(contributionPercent)) {
					it.remove();
				} else {
					bucket.put(CONTRIBUTION, Float.valueOf(contributionPercent));
				}
			}
		}
	}

	/**
	 * Creates the trend annotation.
	 *
	 * @param request
	 *            the request
	 * @return true, if successful
	 * @throws JsonProcessingException
	 *             the json processing exception
	 */
	public boolean createTrendAnnotation(TrendNote request) throws JsonProcessingException {
		return vulnerabilityRepository.createTrendAnnotation(request);
	}

	/**
	 * Gets the trend annotations.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param from
	 *            the from
	 * @return the trend annotations
	 * @throws DataException
	 *             the data exception
	 */
	public List<Map<String, Object>> getTrendAnnotations(String assetGroup, Date from) throws DataException {

		List<Map<String, Object>> globalAnnotations = new ArrayList<>();
		List<Map<String, Object>> assetGroupAnnotations = new ArrayList<>();
		List<Map<String, Object>> annotations = vulnerabilityRepository.getTrendAnnotations(assetGroup, from);

		annotations.parallelStream().forEach(annotation -> {
			if (StringUtils.isEmpty(annotation.get("ag").toString())) {
				synchronized (globalAnnotations) {
					globalAnnotations.add(annotation);
				}
			} else {
				synchronized (assetGroupAnnotations) {
					assetGroupAnnotations.add(annotation);
				}
			}
		});

		Map<String, Object> gloablMap = new HashMap<>();
		gloablMap.put("type", "Global");
		gloablMap.put("data", globalAnnotations);

		Map<String, Object> agMap = new HashMap<>();
		agMap.put("type", "AssetGroup");
		agMap.put("data", assetGroupAnnotations);

		List<Map<String, Object>> noteList = new ArrayList<>();
		noteList.add(agMap);
		noteList.add(gloablMap);

		return noteList;
	}

	/**
	 * Delete trend annotation.
	 *
	 * @param noteId
	 *            the note id
	 * @return true, if successful
	 */
	public boolean deleteTrendAnnotation(String noteId) {
		return vulnerabilityRepository.deleteTrendAnnotation(noteId);
	}

	/**
	 * Gets the vulnerability summary by assets.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @return the vulnerability summary by assets
	 * @throws ServiceException
	 *             the service exception
	 * @throws DataException
	 *             the data exception
	 */
	public Map<String, Object> getVulnerabilitySummaryByAssets(String assetGroup)
			throws ServiceException, DataException {

		List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);

		long totalCount = 0;
		long exemptedCount = 0;
		long inscopeCount = 0;
		long scannedCount = 0;
		long unscannedCount = 0;

		for (String vulnType : vulnTargetTypes) {
			try {
				long tempTotalCount = vulnerabilityRepository.getRunningInstancesCount(assetGroup, vulnType);
				long exemptedByRule = vulnerabilityRepository.getExemptedByRuleCount(assetGroup, vulnType);

				Request request = new Request();
				request.setAg(assetGroup);
				Map<String, String> filter = new HashMap<>();
				filter.put("domain", "Infra & Platforms");

				if (vulnType.equals(EC2)) {
					filter.put("ruleId.keyword", EC2_QUALYS_RULEID);
				} else if (vulnType.equals(VIRTUALMACHINE)) {
					filter.put("ruleId.keyword", VIRTUALMACHINE_QUALYS_RULEID);
				} else {
					filter.put("ruleId.keyword", ONPREM_QUALYS_RULEID);
				}
				request.setFilter(filter);
				//
				// Map<String, Object> response =
				// complianceService.getRulecompliance(request).getResponse().get(0);
				// new code starts
				List<LinkedHashMap<String, Object>> responses = new ArrayList<>();
				Map<String, Object> response = new HashMap<>();
				ResponseEntity<Object> nonCompliancePolicyRuleresponse = complianceServiceClient
						.getNonCompliancePolicyByRule(request);
				if (nonCompliancePolicyRuleresponse != null) {
					Map<String, Object> responseBody = (Map<String, Object>) nonCompliancePolicyRuleresponse.getBody();
					Map<String, Object> dataResponseMap = (Map<String, Object>) responseBody.get("data");
					responses = (List<LinkedHashMap<String, Object>>) dataResponseMap.get("response");
					if (responses.size() > 0) {
						response = responses.get(0);

						// Response response = (Response) dataResponse.get("data");
						// new code ends
						// This inScopeRule is total - exempted by age. SO exemptedByAge would be total-
						// inScopeRule;
						long inScopeRule = Long.valueOf(response.get("assetsScanned").toString());
						long exemptedByAge = tempTotalCount - inScopeRule;
						totalCount += tempTotalCount;
						exemptedCount += exemptedByAge + exemptedByRule;
						inscopeCount += inScopeRule - exemptedByRule; // inScopeRule includes those exempted by Rule as
																		// well.
						scannedCount += Long.valueOf(response.get("passed").toString()) - exemptedByRule;
						unscannedCount += Long.valueOf(response.get("failed").toString());
					}
				}
			} catch (Exception e) {
				throw new ServiceException(e);
			}
		}

		long nonCompliantCount = vulnerabilityRepository.getNonCompliantResourceIds(assetGroup).size();

		Map<String, Object> compliant = vulnerabilityRepository.getCompliantHostsBySeverity(assetGroup);
		Map<String, Object> noncompliant = vulnerabilityRepository.getUniqueHostBySeverity(assetGroup, "3,4,5");

		noncompliant.put("S3",
				Long.valueOf(noncompliant.get("S3").toString()) - Long.valueOf(compliant.get("S3").toString()));
		noncompliant.put("S4",
				Long.valueOf(noncompliant.get("S4").toString()) - Long.valueOf(compliant.get("S4").toString()));

		for (String key : compliant.keySet()) {
			Map<String, Long> countMap = new HashMap<>();
			countMap.put(COUNT, Long.valueOf(compliant.get(key).toString()));
			compliant.put(key, countMap);
		}

		for (String key : noncompliant.keySet()) {
			Map<String, Long> countMap = new HashMap<>();
			countMap.put(COUNT, Long.valueOf(noncompliant.get(key).toString()));
			noncompliant.put(key, countMap);
		}

		Map<String, Object> response = new HashMap<>();
		response.put(COUNT, totalCount);

		Map<String, Object> exempted = new HashMap<>();
		exempted.put(COUNT, exemptedCount);
		response.put("exempted", exempted);

		Map<String, Object> inscope = new HashMap<>();
		inscope.put(COUNT, inscopeCount);
		Map<String, Object> unscanned = new HashMap<>();
		unscanned.put(COUNT, unscannedCount);
		inscope.put("unscanned", unscanned);
		Map<String, Object> scanned = new HashMap<>();
		scanned.put(COUNT, scannedCount);

		compliant.put(COUNT, scannedCount - nonCompliantCount);
		scanned.put("compliant", compliant);
		noncompliant.put(COUNT, nonCompliantCount);
		scanned.put("noncompliant", noncompliant);

		inscope.put("scanned", scanned);
		response.put("inscope", inscope);

		return response;
	}

	/**
	 * Gets the vulnerability assets trend.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param severity
	 *            the severity
	 * @param from
	 *            the from
	 * @return the vulnerability assets trend
	 * @throws DataException
	 *             the data exception
	 */
	public List<Map<String, Object>> getVulnerabilityAssetsTrend(String assetGroup, String severity, Date from)
			throws DataException {

		List<Map<String, Object>> dateList = new ArrayList<>();

		List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
		Map<String, Long> totalAssetsEc2 = new HashMap<>();
		Map<String, Long> totalAssetsOnPrem = new HashMap<>();

		Map<String, Long> totalAssetsAffected = new HashMap<>();

		ExecutorService executionService = Executors.newFixedThreadPool(3);
		LocalDate fromDate = LocalDate.parse(new SimpleDateFormat("yyyy-MM-dd").format(from));
		
		executionService.execute(() -> {
			try {
				long start = System.currentTimeMillis();
				totalAssetsAffected.putAll(vulnTrendGenerator.fetchAssetsAffected(assetGroup, fromDate, severity));
				System.out.println("Time taken assset affected " + (System.currentTimeMillis() - start));
			} catch (Exception e) {
				logger.error("Error in fetchAssetsAffected fetch", e);
			}
		});

		for (String vulnType : vulnTargetTypes) {
			
			switch(vulnType) {
			
				case  EC2 : {
					executionService.execute(() -> {
						try {
							long start = System.currentTimeMillis();
							totalAssetsEc2.putAll(
									vulnTrendGenerator.fetchAssetsDateRangesForEc2(assetGroup, fromDate));
							//parallelStream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting())));
							System.out.println("Time taken EC2 Find ALL" + (System.currentTimeMillis() - start));
						} catch (Exception e) {
							logger.error("Error in getVulnerabilityAssetsTrend fetch assets for EC2", e);
						}
					});
					break;
				}
				case ONPREMSERVER : {
					executionService.execute(() -> {
						long start = System.currentTimeMillis();
	
						try {
							totalAssetsOnPrem.putAll(
									vulnTrendGenerator.fetchAssetsDateRangesOnPrem(assetGroup, fromDate).parallelStream()
											.collect(Collectors.groupingBy(Function.identity(), Collectors.counting())));
							System.out.println("Time taken ONPREM Find ALL" + (System.currentTimeMillis() - start));
	
						} catch (Exception e) {
							logger.error("Error in getVulnerabilityAssetsTrend fetch assets for On Prem", e);
						}
					});
					break;
	
				}
			}
		}
		
		executionService.shutdown();
		while (!executionService.isTerminated())
			;

		Map<String, Long> totalAssets = addMapValues(totalAssetsEc2, totalAssetsOnPrem);

		totalAssets.entrySet().forEach(entry -> {
			Map<String, Object> dateObj = new HashMap<>();
			String date = entry.getKey();
			Long asset = entry.getValue();
			Long assetAffected = totalAssetsAffected.get(date);

			dateObj.put("date", date);
			dateObj.put("totalAssets", asset);
			dateObj.put("assetsAffected", assetAffected == null ? 0l : assetAffected);
			dateList.add(dateObj);

		});

		return dateList;
	}

	/**
	 * Adds the map values.
	 *
	 * @param ec2Assets
	 *            the ec2 assets
	 * @param onpremAssets
	 *            the onprem assets
	 * @return the map
	 */
	private Map<String, Long> addMapValues(Map<String, Long> ec2Assets, Map<String, Long> onpremAssets) {
		Map<String, Long> totalMap = new HashMap<>(ec2Assets);
		for (String key : onpremAssets.keySet()) {
			if (totalMap.containsKey(key)) {
				totalMap.put(key, onpremAssets.get(key) + totalMap.get(key));
			} else {
				totalMap.put(key, onpremAssets.get(key));
			}
		}
		return totalMap;
	}

	public Map<String, Map<String, String>> getDirectorsForAGByApp(Set<String> appNames) throws Exception {
		Map<String, Map<String, String>> directorsInfo = new HashMap<>();
		ObjectMapper mapper = new ObjectMapper();

		vulnerabilityRepository.fetchOrgInfoForApps().forEach(app -> {
			try {
				if (appNames.contains(app.get(APP_TAG))) {
					List<Map<String, String>> orgInfo = new ArrayList<>();
					if (null != app.get("list")) {
						orgInfo.addAll(mapper.readValue(app.get("list").toString(),
								new TypeReference<List<Map<String, String>>>() {
								}));
					}
					orgInfo.forEach(info -> {
						if (directorsInfo.containsKey(info.get("mgmntLevel"))) {
							directorsInfo.get(info.get("mgmntLevel")).put(app.get(APP_TAG).toString(),
									info.get("name"));
						} else {
							Map<String, String> director = new HashMap<>();
							director.put(app.get(APP_TAG).toString(), info.get("name"));
							directorsInfo.put(info.get("mgmntLevel"), director);
						}
					});
				}
			} catch (Exception e) {
				logger.error("Error in getDirectorsForAG ", e);
			}
		});
		return directorsInfo;
	}

	private Map<String, Map<String, List<String>>> getDirectorsForAG(Set<String> appNames) throws Exception {

		Map<String, Map<String, List<String>>> directorsInfo = new HashMap<>();
		ObjectMapper mapper = new ObjectMapper();

		vulnerabilityRepository.fetchOrgInfoForApps().forEach(app -> {
			try {
				if (appNames.contains(app.get(APP_TAG))) {
					List<Map<String, String>> orgInfo = new ArrayList<>();
					if (null != app.get("list")) {
						orgInfo.addAll(mapper.readValue(app.get("list").toString(),
								new TypeReference<List<Map<String, String>>>() {
								}));
					}
					orgInfo.forEach(info -> {
						if (directorsInfo.containsKey(info.get("mgmntLevel"))) {
							if (directorsInfo.get(info.get("mgmntLevel")).containsKey(info.get("name"))) {
								directorsInfo.get(info.get("mgmntLevel")).get(info.get("name"))
										.add(app.get(APP_TAG).toString());
							} else {
								List<String> apps = new ArrayList<>();
								apps.add(app.get(APP_TAG).toString());
								directorsInfo.get(info.get("mgmntLevel")).put(info.get("name"), apps);
							}
						} else {
							Map<String, List<String>> director = new HashMap<>();
							List<String> apps = new ArrayList<>();
							apps.add(app.get(APP_TAG).toString());
							director.put(info.get("name"), apps);
							directorsInfo.put(info.get("mgmntLevel"), director);
						}
					});
				}
			} catch (Exception e) {
				logger.error("Error in getDirectorsForAG ", e);
			}
		});
		return directorsInfo;
	}

	private void formPerformersData(Map<String, Long> appDetails, Map<String, Integer> perfData,
			Map<String, List<String>> directApp) {
		for (Entry<String, List<String>> entry : directApp.entrySet()) {

			String director = entry.getKey();
			int directorVuln = 0;
			for (String app : entry.getValue()) {
				directorVuln += appDetails.get(app);
			}

			if (!perfData.isEmpty()) {
				boolean directorExists = false;
				for (Entry<String, Integer> existingDirectorData : perfData.entrySet()) {
					if (director.equals(existingDirectorData.getKey())) {
						perfData.put(director, existingDirectorData.getValue() + directorVuln);
						directorExists = true;
						break;
					}
				}
				if (!directorExists) {
					perfData.put(director, directorVuln);
				}
			} else {
				perfData.put(director, directorVuln);
			}
		}
	}

	private void formDistributionSummaryDetails(Map<String, String> directApp, String appName,
			List<Map<String, Object>> directorData, Map<String, Object> sevInfo, String severity) {
		if (!directorData.isEmpty()) {
			if (StringUtils.isNotEmpty(directApp.get(appName))) {
				String director = directApp.get(appName);
				boolean directorExists = false;
				for (Map<String, Object> existingDirectorData : directorData) {
					if (director.equals(existingDirectorData.get("name"))) {
						existingDirectorData.put(COUNT, Integer.valueOf(existingDirectorData.get(COUNT).toString())
								+ Integer.valueOf(sevInfo.get("S" + severity).toString()));
						directorExists = true;
						break;
					}
				}
				if (!directorExists) {
					Map<String, Object> directorTemp = new HashMap<>();
					directorTemp.put("name", director);
					directorTemp.put(COUNT, sevInfo.get("S" + severity));
					directorData.add(directorTemp);
				}
			}
		} else {
			if (StringUtils.isNotEmpty(directApp.get(appName))) {
				Map<String, Object> directorTemp = new HashMap<>();
				directorTemp.put("name", directApp.get(appName));
				directorTemp.put(COUNT, sevInfo.get("S" + severity));
				directorData.add(directorTemp);
			}
		}
	}

	private void formAgingDistributionSummaryDetails(Map<String, String> directApp, String appName,
			List<Map<String, Object>> directorData, Map<String, Object> sevInfo, String severity) {
		if (!directorData.isEmpty()) {
			if (StringUtils.isNotEmpty(directApp.get(appName))) {
				String director = directApp.get(appName);
				boolean directorExists = false;
				for (Map<String, Object> existingDirectorData : directorData) {
					if (director.equals(existingDirectorData.get("name"))) {
						existingDirectorData.put("days", Double.valueOf(existingDirectorData.get("days").toString())
								+ Double.valueOf(sevInfo.get("days").toString()));
						existingDirectorData.put(COUNT, Double.valueOf(existingDirectorData.get(COUNT).toString())
								+ Double.valueOf(sevInfo.get(COUNT).toString()));
						directorExists = true;
						break;
					}
				}
				if (!directorExists) {
					Map<String, Object> directorTemp = new HashMap<>();
					directorTemp.put("name", director);
					directorTemp.put("days", sevInfo.get("days"));
					directorTemp.put(COUNT, sevInfo.get(COUNT));
					directorData.add(directorTemp);
				}
			}
		} else {
			if (StringUtils.isNotEmpty(directApp.get(appName))) {
				Map<String, Object> directorTemp = new HashMap<>();
				directorTemp.put("name", directApp.get(appName));
				directorTemp.put("days", sevInfo.get("days"));
				directorTemp.put(COUNT, sevInfo.get(COUNT));
				directorData.add(directorTemp);
			}
		}
	}

	private void validatingAgingDays(List<Map<String, Object>> directorData) {

		directorData.parallelStream().forEach(director -> {
			if (director.get(COUNT).toString().equals(ZERO) || director.get(COUNT).toString().equals(DOUBLE_ZERO)) {
				director.put("days", 0);
			} else {
				director.put("days", Math.floor(Double.valueOf(director.get("days").toString())
						/ Double.valueOf(director.get(COUNT).toString())));
			}
			director.remove(COUNT);
		});
	}

	public ResponseEntity<Object> formatException(ServiceException e) {
		if (e.getMessage().contains(NO_DATA_FOUND)) {
			List<Map<String, Object>> emptylist = new ArrayList<>();
			ResponseData res = new ResponseData(emptylist);
			return ResponseUtils.buildSucessResponse(res);
		} else {
			return ResponseUtils.buildFailureResponse(e);
		}
	}

	public Map<String, Object> getTrendProgress(String assetGroup, String ruleId, LocalDate startDate,
			LocalDate endDate, String trendCategory) throws ServiceException {

		List<Map<String, Object>> trendList;
		try {
			trendList = vulnerabilityRepository.getTrendProgress(assetGroup, ruleId, startDate, endDate, trendCategory);
		} catch (DataException e) {
			throw new ServiceException(e);
		}
		if (!trendList.isEmpty()) {

			// Sort the list by the date in ascending order
			Comparator<Map<String, Object>> comp = (m1, m2) -> LocalDate
					.parse(m1.get("date").toString(), DateTimeFormatter.ISO_DATE)
					.compareTo(LocalDate.parse(m2.get("date").toString(), DateTimeFormatter.ISO_DATE));
			Collections.sort(trendList, comp);
			LocalDate trendStartDate = LocalDate.parse(trendList.get(0).get("date").toString());

			// Elastic Search might not have data for some dates. But we want to
			// send consistent data to the consumers of this service, so we will
			// populate previous where data is unavailable
			fillNoDataDatesWithPrevious(trendList, trendStartDate, endDate);

			useRealTimeDataForLatestDate(trendList, assetGroup, trendCategory, ruleId, null);

			// ADD compliance_percent if not available . This is done
			// temporarily.Will update with compliance_percent at source

			appendWithCompliancePercent(trendList);

			return segregateTrendProgressByWeek(assetGroup, trendList, trendStartDate, endDate);
		} else {
			return new HashMap<>();
		}
	}

	/**
	 * Segregate trend progress by week.
	 *
	 * @param assetGroup
	 *            the asset group
	 * @param trendProgressList
	 *            the trend progress list
	 * @param startDate
	 *            the start date
	 * @param endDate
	 *            the end date
	 * @return the map
	 */
	private Map<String, Object> segregateTrendProgressByWeek(String assetGroup,
			List<Map<String, Object>> trendProgressList, LocalDate startDate, LocalDate endDate) {

		long maxInstancesForTheCompleteDateRange = 0;

		long totalNumberRunningValue = 0;
		long compliantRunningValue = 0;
		long noncompliantRunningValue = 0;
		double complianceRunningValue = 0;

		List<Map<String, Object>> allWeeksDataList = new ArrayList<>();

		// The first day of date range is taken as the first day of week 1 of
		// the
		// quarter. This
		// could be a Monday, Thursday or ANY day.
		LocalDate startingDayOfWeek = startDate;

		// Add 6 days to get the end date. If we start on a Thursday, the week
		// ends on next Wednesday
		LocalDate endingDayOfWeek = startingDayOfWeek.plusDays(SIX);

		List<Map<String, Object>> trendListForTheWeek = new ArrayList<>();

		// We will send 100 weeks at most. Start with week 1(There
		// is no week zero!)
		for (int weekNumber = 1; weekNumber <= HUNDRED; weekNumber++) {

			LocalDate startingDayOfWeekLocalCopy = startingDayOfWeek;
			LocalDate endingDayOfWeekLocalCopy = endingDayOfWeek;

			trendProgressList.forEach(ruleTrendProgressMap -> ruleTrendProgressMap.forEach((key, value) -> {

				if ("date".equals(key)) {

					// Check if this date falls in the week that we are
					// currently interested in
					LocalDate dateInThisIteration = LocalDate.parse(value.toString(), DateTimeFormatter.ISO_DATE);
					if (dateInThisIteration.isAfter(startingDayOfWeekLocalCopy.minusDays(1))
							&& (dateInThisIteration.isBefore(endingDayOfWeekLocalCopy.plusDays(1)))) {
						// If the date matches, lets pick the map which
						// represents this date's patching data and add
						// it to
						// the weeks list
						trendListForTheWeek.add(ruleTrendProgressMap);
					}

				}

			}));

			Map<String, Object> mapForTheWeek = new LinkedHashMap<>();

			// First some k-v pairs for week number,week start date, week end
			// date
			mapForTheWeek.put("week", weekNumber);
			mapForTheWeek.put("start_date", startingDayOfWeek.format(DateTimeFormatter.ISO_DATE));
			mapForTheWeek.put("end_date", endingDayOfWeek.format(DateTimeFormatter.ISO_DATE));

			// Lets calculate the compliance for the week. We simply get the
			// compliance for the last day of the week

			complianceRunningValue = calculateWeeklyCompliance(trendListForTheWeek);
			mapForTheWeek.put(COMPLIANCE_PERCENTAGE, complianceRunningValue);
			trendListForTheWeek.forEach(ruleTrendProgressMap -> {
				// We don't need _id in the response
				ruleTrendProgressMap.remove("_id");
			});

			// Store a 'copy' of the weeks array list instead of the original,
			// as we will clear the original and reuse it for the next
			// iteration. Lets call this by the key 'compliance_info'
			mapForTheWeek.put("compliance_info", new ArrayList<Map<String, Object>>(trendListForTheWeek));

			if (!trendListForTheWeek.isEmpty()) {
				allWeeksDataList.add(mapForTheWeek);

				totalNumberRunningValue = (long) getLatestDaysNumericDataFromAWeeklyDataList(TOTAL,
						trendListForTheWeek);
				compliantRunningValue = (long) getLatestDaysNumericDataFromAWeeklyDataList(COMPLAINT,
						trendListForTheWeek);
				noncompliantRunningValue = (long) getLatestDaysNumericDataFromAWeeklyDataList(NON_COMPLIANT,
						trendListForTheWeek);

				// Maintain a max instance number for the quarter that is being
				// processed.
				long maxInstancesRunningValue = (long) getMaxValueNumericDataFromAWeeklyDataList(TOTAL,
						trendListForTheWeek);
				if (maxInstancesRunningValue > maxInstancesForTheCompleteDateRange) {
					maxInstancesForTheCompleteDateRange = maxInstancesRunningValue;
				}

			}

			// Now, lets get ready for the iteration for next week
			trendListForTheWeek.clear();
			startingDayOfWeek = startingDayOfWeek.plusDays(7);
			endingDayOfWeek = endingDayOfWeek.plusDays(7);

			// If week ending date bypasses the quarter end date, lets rewind
			// back to quarter end date. The quarter end date will be set as the
			// week ending date.
		}

		Map<String, Object> quarterlyDataMap = new LinkedHashMap<>();
		quarterlyDataMap.put("ag", assetGroup);
		quarterlyDataMap.put("start_date", startDate.format(DateTimeFormatter.ISO_DATE));
		quarterlyDataMap.put("end_date", endDate.format(DateTimeFormatter.ISO_DATE));
		quarterlyDataMap.put("max", maxInstancesForTheCompleteDateRange);
		quarterlyDataMap.put(TOTAL, totalNumberRunningValue);
		quarterlyDataMap.put(COMPLAINT, compliantRunningValue);
		quarterlyDataMap.put(NON_COMPLIANT, noncompliantRunningValue);
		quarterlyDataMap.put(COMPLIANCE_PERCENTAGE, complianceRunningValue);

		quarterlyDataMap.put("compliance_trend", allWeeksDataList);

		return quarterlyDataMap;

	}

	private void fillNoDataDatesWithPrevious(List<Map<String, Object>> trendList, LocalDate firstDay,
			LocalDate lastDay) {

		// We don't want data for future weeks. If the quarter being
		// requested is the ongoing quarter, the max we we are interested
		// is data up to and including the ongoing day in the ongoing week.
		if (lastDay.isAfter(LocalDate.now())) {
			lastDay = LocalDate.now();
		}

		List<LocalDate> listOfAllDates = new ArrayList<>();

		LocalDate iterationDate = firstDay;

		// Have a temp variable called iterationDate. Keep incrementing it by 1,
		// until we reach the end date. In each such iteration, add each date to
		// our list of dates
		while (!iterationDate.isAfter(lastDay)) {
			listOfAllDates.add(iterationDate);
			iterationDate = iterationDate.plusDays(1);
		}

		// Iterate through each date. If the data from ES is missing for any
		// such
		// date, add a dummy map with zero values
		Map<String, Object> currentData = new LinkedHashMap<>();
		currentData.put(TOTAL, 0);
		currentData.put(COMPLAINT, 0);
		currentData.put(NON_COMPLIANT, 0);
		currentData.put(COMPLIANCE_PERCENT, HUNDRED);

		for (int i = 0; i < listOfAllDates.size(); i++) {
			LocalDate date = listOfAllDates.get(i);
			Map<String, Object> trendInfo = getTrendDataForDate(trendList, date);
			if (trendInfo == null) {
				trendInfo = new LinkedHashMap<>();
				trendInfo.put("date", date.format(DateTimeFormatter.ISO_DATE));
				trendInfo.put(NON_COMPLIANT, currentData.get(NON_COMPLIANT));
				trendInfo.put(TOTAL, currentData.get(TOTAL));
				trendInfo.put(COMPLAINT, currentData.get(COMPLAINT));
				if (currentData.get(COMPLIANCE_PERCENT) != null) {
					trendInfo.put(COMPLIANCE_PERCENT, currentData.get(COMPLIANCE_PERCENT));
				}
				trendList.add(i, trendInfo);
			} else {
				currentData = trendInfo;
			}
		}

	}

	/**
	 * Gets the trend data for date.
	 *
	 * @param trendList
	 *            the trend list
	 * @param date
	 *            the date
	 * @return the trend data for date
	 */
	private Map<String, Object> getTrendDataForDate(List<Map<String, Object>> trendList, LocalDate date) {

		List<Map<String, Object>> match = trendList.stream().filter(trendMap -> {
			LocalDate dateInThisIteration = LocalDate.parse(trendMap.get("date").toString(),
					DateTimeFormatter.ISO_DATE);
			return dateInThisIteration.isEqual(date);
		}).collect(Collectors.toList());
		if (match != null && !match.isEmpty()) {
			return match.get(0);
		}
		return null;
	}

	public void useRealTimeDataForLatestDate(List<Map<String, Object>> trendList, String ag, String trendCategory,
			String ruleId, String domain) throws ServiceException {
		Map<String, Object> latestDaysTrendData = new HashMap<>(trendList.get(trendList.size() - 1));
		Map<String, Long> baseApiReturnMap = new HashMap<>();
		Map<String, Object> overallCompliance = new HashMap<>();
		long compliantQuantity = 0;
		long noncompliantQuantity = 0;
		long total = 0;
		double compliance;
		LocalDate today;
		try {
			switch (trendCategory) {

			case "vulncompliance":
				Map<String, Object> vulnSummary = getVulnerabilitySummary(ag, SEVERITY_LEVELS);
				total = Long.valueOf(vulnSummary.get("hosts").toString());
				noncompliantQuantity = Long.valueOf(vulnSummary.get("totalVulnerableAssets").toString());
				compliantQuantity = total - noncompliantQuantity;

				latestDaysTrendData.put(COMPLAINT, compliantQuantity);
				latestDaysTrendData.put(NON_COMPLIANT, noncompliantQuantity);
				latestDaysTrendData.put(TOTAL, total);
				if (total > 0) {
					compliance = Math.floor(compliantQuantity * HUNDRED / total);
				} else {
					compliance = INT_HUNDRED;
				}
				latestDaysTrendData.put(COMPLIANCE_PERCENT, compliance);
				break;

			default:
				// nothings
			}

			// Check if the trend already has todays data (Compare dates)
			// If yes, overwrite. If not, add at the end.
			LocalDate date = null;
			today = LocalDate.now();
			date = LocalDate.parse(latestDaysTrendData.get("date").toString(), DateTimeFormatter.ISO_LOCAL_DATE);

			if (date.isEqual(today)) {
				logger.info("Latest days data available in trend data, so overwriting");
				trendList.set(trendList.size() - 1, latestDaysTrendData);
			} else if (date.isEqual(today.minusDays(1))) {
				// Ideally we need to consider this case only else, we may
				// unnecessarily append wrong data. FOr eg. In case of patching
				// if any previous/ progress is requested.
				logger.info("Latest days data is NOT available in trend data, so adding at the end");
				latestDaysTrendData.put("date", today.format(DateTimeFormatter.ISO_LOCAL_DATE));
				trendList.add(latestDaysTrendData);
			}

		} catch (ServiceException e) {
			logger.error("Call to Base API to get todays data failed", e);
			return;
		}

	}

	/**
	 * Append with compliance percent.
	 *
	 * @param trendList
	 *            the trend list
	 */
	private void appendWithCompliancePercent(List<Map<String, Object>> trendList) {

		trendList.parallelStream().forEach(trend -> {
			if (trend.get(COMPLIANCE_PERCENT) == null) {
				double total = Double.parseDouble(trend.get(TOTAL).toString());
				double compliant = Double.parseDouble(trend.get(COMPLAINT).toString());
				double compliancePercent = HUNDRED;
				if (total > 0) {
					compliancePercent = Math.floor(compliant * HUNDRED / total);
				}
				trend.put(COMPLIANCE_PERCENT, compliancePercent);
			}
		});
	}

	/**
	 * Calculate weekly compliance.
	 *
	 * @param trendProgressListForTheWeek
	 *            the trend progress list for the week
	 * @return the double
	 */
	private double calculateWeeklyCompliance(List<Map<String, Object>> trendProgressListForTheWeek) {

		int index = trendProgressListForTheWeek.size() - 1;
		while (index >= 0) {
			Object percentObj = trendProgressListForTheWeek.get(index).get(COMPLIANCE_PERCENT);
			if (null != percentObj && Double.valueOf(percentObj.toString()) != 0) {
				return Double.valueOf(percentObj.toString());
			}
			index--;
		}
		return HUNDRED;

	}

	/**
	 * Gets the max value numeric data from A weekly data list.
	 *
	 * @param dataKeyName
	 *            the data key name
	 * @param trendProgressListForTheWeek
	 *            the trend progress list for the week
	 * @return the max value numeric data from A weekly data list
	 */
	private double getMaxValueNumericDataFromAWeeklyDataList(String dataKeyName,
			List<Map<String, Object>> trendProgressListForTheWeek) {

		double maxValue = 0;
		int index = trendProgressListForTheWeek.size() - 1;

		while (index >= 0) {
			Object obj = trendProgressListForTheWeek.get(index).get(dataKeyName);
			if (null != obj && Double.valueOf(obj.toString()) != 0 && (Double.valueOf(obj.toString()) > maxValue)) {
				maxValue = Double.valueOf(obj.toString());
			}
			index--;
		}

		return maxValue;
	}

	/**
	 * Gets the latest days numeric data from A weekly data list.
	 *
	 * @param dataKeyName
	 *            the data key name
	 * @param ruleTrendProgressListForTheWeek
	 *            the rule trend progress list for the week
	 * @return the latest days numeric data from A weekly data list
	 */
	private double getLatestDaysNumericDataFromAWeeklyDataList(String dataKeyName,
			List<Map<String, Object>> ruleTrendProgressListForTheWeek) {

		int index = ruleTrendProgressListForTheWeek.size() - 1;

		// We take the latest days data, provided its a non-zero value
		while (index >= 0) {
			Object obj = ruleTrendProgressListForTheWeek.get(index).get(dataKeyName);
			if (null != obj && Double.valueOf(obj.toString()) != 0) {
				return Double.valueOf(obj.toString());
			}
			index--;
		}

		return 0;
	}

	public List<String> getResourceId(List<Map<String, Object>> vulnerabilityOccuranceList) {
		List<String> resourceIdList = new ArrayList<String>();
		for (Map<String, Object> map : vulnerabilityOccuranceList) {
			for (Map.Entry<String, Object> entry : map.entrySet()) {
				String key = entry.getKey();
				if (key.equals("_resourceid")) {
					String value = entry.getValue().toString();
					resourceIdList.add(value);
				}

			}
		}
		return resourceIdList.stream().distinct().collect(Collectors.toList());
	}

	public List<Map<String, Object>> getCartesianProduct(List<Map<String, Object>> vulnerabilityOccuranceList,
			List<Map<String, Object>> resourceIdDetails) {
		List<Map<String, Object>> finalVulnerabilityOccuranceList = new ArrayList<Map<String, Object>>();
		LinkedHashMap<String, Map<String, Object>> mapOfResourceAttributeMap = new LinkedHashMap<String, Map<String, Object>>();
		for (Map<String, Object> resourceAttributeMap : resourceIdDetails) {
			mapOfResourceAttributeMap.put((String) resourceAttributeMap.get("_resourceid"), resourceAttributeMap);
		}

		/*
		 * mapOfResourceAttributeMap = resourceIdDetails.stream()
		 * .collect(Collectors.toMap(obj -> obj.get("_resourceid").toString(), obj ->
		 * obj));
		 */
		for (Map<String, Object> vulnerabilityOccuranceMap : vulnerabilityOccuranceList) {
			LinkedHashMap<String, Object> finalVulnerabilityOccuranceMap = new LinkedHashMap<>(
					vulnerabilityOccuranceMap);
			String resourceId = (String) vulnerabilityOccuranceMap.get("_resourceid");
			if (!mapOfResourceAttributeMap.containsKey(resourceId)) {
				continue;
			}

			finalVulnerabilityOccuranceMap.putAll(mapOfResourceAttributeMap.get(resourceId));
			finalVulnerabilityOccuranceList.add(finalVulnerabilityOccuranceMap);
		}

		return finalVulnerabilityOccuranceList;
	}

	public int vulnerabilityAssetCount(String assetGroup, Map<String, String> termsFilter, String applicationFilter,
			String environmentFilter, int from, int size) throws Exception {

		List<String> vulnTargetTypes = getVulnTargetTypes(assetGroup);
		int totalCount = 0;
		if (!vulnTargetTypes.isEmpty()) {
			for (String parentType : vulnTargetTypes) {
				totalCount = totalCount + countForTargetType(assetGroup, parentType, termsFilter, applicationFilter,
						environmentFilter, from, size);
			}
		}
	
		return totalCount;
	}

	public int countForTargetType(String assetGroup, String parentType, Map<String, String> termsFilter,
			String applicationFilter, String environmentFilter, int from, int size) throws Exception {
		int count = 0;
		String targetType = "vulninfo";
		Map<String, Object> mustFilterMap = new LinkedHashMap<>();
		mustFilterMap.put("latest", "true");
		Map<String, Object> parentBool = new HashMap<>();
		List<Map<String, Object>> mustList = new ArrayList<>();
		Map<String, Object> matchMap = new HashMap<>();
		Map<String, String> match = new HashMap<>();
		Map<String, Object> mustTermsFilter = new HashMap<>();
		for (Map.Entry<String, String> entry : termsFilter.entrySet()) {
			List<String> severities = Arrays.asList(entry.getValue().split(","));
			mustTermsFilter.put(entry.getKey(), severities);
		}
		match.put(Constants.LATEST, Constants.TRUE);
		matchMap.put(Constants.MATCH, match);
		mustList.add(matchMap);

		if (applicationFilter != null) {
			Map<String, String> applicationFilterMap = new HashMap<String, String>();
			Map<String, Object> applicationFilterMap1 = new HashMap<String, Object>();
			applicationFilterMap.put("tags.Application.keyword", applicationFilter);
			applicationFilterMap1.put("match", applicationFilterMap);
			mustList.add(applicationFilterMap1);
		}

		if (environmentFilter != null) {
			Map<String, String> environmentFilterMap = new HashMap<String, String>();
			Map<String, Object> environmentFilterMap1 = new HashMap<String, Object>();
			environmentFilterMap.put("tags.Environment.keyword", environmentFilter);
			environmentFilterMap1.put("match", environmentFilterMap);
			mustList.add(environmentFilterMap1);
		}

		parentBool.put("must", mustList);
		Map<String, Object> queryMap = new HashMap<>();
		queryMap.put("bool", parentBool);
		Map<String, Object> parentEntryMap = new LinkedHashMap<>();
		parentEntryMap.put("parent_type", parentType);
		parentEntryMap.put("query", queryMap);
		mustFilterMap.put("has_parent", parentEntryMap);
		count = vulnerabilityRepository.vulnerabilityAssetsCount(assetGroup, targetType, mustFilterMap, from, size,
				mustTermsFilter);
		logger.info("vulnerability asset count {} " + count);
		return count;

	}
}
