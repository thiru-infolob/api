/*******************************************************************************
 * Copyright 2018 T Mobile, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
/**
  Copyright (C) 2017 T Mobile Inc - All Rights Reserve
  Purpose:
  Author :kkumar28
  Modified Date: Oct 20, 2017
  
 **/
package com.tmobile.pacman.api.vulnerability.repository;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import org.apache.http.HttpEntity;
import org.apache.http.HttpHost;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.entity.ContentType;
import org.apache.http.nio.entity.NStringEntity;
import org.apache.http.util.EntityUtils;
import org.elasticsearch.client.RestClient;
import org.elasticsearch.client.RestClientBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Repository;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.google.gson.reflect.TypeToken;
import com.tmobile.pacman.api.commons.Constants;
import com.tmobile.pacman.api.commons.exception.DataException;
import com.tmobile.pacman.api.commons.utils.PacHttpUtils;


/**
 * The Class VulnerabilityTrendGenerator.
 */
@Repository
public class VulnerabilityTrendGenerator implements Constants {

    /** The es host. */
    @Value("${elastic-search.host}")
    private String esHost;
    
    /** The es port. */
    @Value("${elastic-search.port}")
    private int esPort;
    
    /** The es cluster name. */
    @Value("${elastic-search.clusterName}")
    private String esClusterName;
    
    /** The date format. */
    @Value("${formats.date}")
    private String dateFormat;
        
    /** The Constant LOGGER. */
    private static final Logger LOGGER = LoggerFactory
            .getLogger(VulnerabilityTrendGenerator.class);

    /**
     * Generate trend.
     *
     * @param ag the ag
     * @param severity the severity
     * @param fromDate the from date
     * @return the list
     * @throws Exception the exception
     */
   
    public List<Map<String, Object>> generateTrend(String ag,String severity, Date fromDate) throws Exception {
        //long start = System.currentTimeMillis();
        List<Map<String, Object>> dateList = new ArrayList<>();
        LocalDate from = LocalDate.parse(new SimpleDateFormat("yyyy-MM-dd").format(fromDate));
       
       
       
        String queryBody = "\"query\":{\"bool\":{\"must\":[{\"terms\":{\"severitylevel.keyword\":["+severity+"]}}],\"should\":[{\"range\":{\"_closedate\":{\"gte\":\""+from+"\"}}},{\"match\":{\"_status\":\"open\"}}],\"minimum_should_match\":1}}";
        
        
        long totalCount = getTotalDocCount(ag,"vulninfo","{"+queryBody+"}");
        //System.out.println("TOtal Count Open New"+totalCount);
        if (totalCount > 0) {
            
            
            List<String> issueOpenDates = new ArrayList<>();
            ExecutorService executionService = Executors.newFixedThreadPool(2);
            Map<String,Long> newFoundMap = new HashMap<>();
            Map<String,Long> openCountMap = new HashMap<>();
            executionService.execute(()-> {
                newFoundMap.putAll(fetchNewlyFoundVulnByDay(ag,severity,from));
            });
          
            executionService.execute( () -> {
                
                // ES needs minimum 2 slices, if records are less , we need to slice
                // accordingly
                final int scrollSize = totalCount > 10000 ? 10000
                        : (int) (totalCount / 2) + 1;
                
                final int slices = totalCount > scrollSize ? (int) totalCount
                        / scrollSize + 1 : 2;
           
                IntStream.range(0, slices)
                        .parallel()
                        .forEach(i -> {
                            List<String> issueOpenDatesList = fetchVulnInfoDateRanges(ag,scrollSize,slices,i,queryBody,from);
                            synchronized(issueOpenDates){
                                issueOpenDates.addAll(issueOpenDatesList);
                            }
                         });
                
                openCountMap.putAll(issueOpenDates.parallelStream().collect(Collectors.groupingBy(Function.identity(), Collectors.counting())));
              
                });
            
            executionService.shutdown();
            while(!executionService.isTerminated()){}
            
            
            
            openCountMap.entrySet().forEach(entry->{
                Map<String,Object> dateObj = new HashMap<>();
                String date = entry.getKey();
                Long open = entry.getValue();
                Long newlyFound = newFoundMap.get(date);
                
                dateObj.put("date",date);
                dateObj.put("open",open);
                dateObj.put("new",newlyFound==null?0l:newlyFound);
                dateList.add(dateObj);
                
            });
            //System.out.println("Time taken Generate Trend :"+(System.currentTimeMillis()-start));
            return dateList ;
        } else {

            throw new DataException(NO_DATA_FOUND);
        }
    }
    
    /**
     * Fetch newly found vuln by day.
     *
     * @param ag the ag
     * @param severity the severity
     * @param from the from
     * @return the map
     */
    private Map<String,Long> fetchNewlyFoundVulnByDay(String ag,String severity,LocalDate from ){
        
        StringBuilder queryBody = new StringBuilder();
        queryBody.append("\"query\":{\"bool\":{\"must\":[").
            append("{\"terms\":{\"severitylevel.keyword\":["+severity+"]}}").
            append(",{\"range\":{\"_firstFound\":{\"gte\":\"").
            append(from.toString()).
            append("\"}}}]}}");
    
        String searchUrl = "http://"+esHost+":"+esPort+"/"+ag+"/vulninfo/_search?size=0";
        StringBuilder request = new StringBuilder();
        request.append("{").
            append("\"aggs\":{\"dates\":{\"date_histogram\":{\"field\":\"_firstFound\",\"interval\":\"day\",\"format\":\"yyyy-MM-dd\"}}}").
            append(",").append(queryBody).append("}");
        
        Map<String,Long> newFoundMap = new HashMap<>();
        try {
            String searchResponse = PacHttpUtils.doHttpPost(searchUrl, request.toString());
            JsonParser parser = new JsonParser();
            JsonObject responeObj = parser.parse(searchResponse).getAsJsonObject();
            JsonArray dateBuckets = responeObj.getAsJsonObject("aggregations").getAsJsonObject("dates").getAsJsonArray("buckets");
            for(JsonElement jsonElement:dateBuckets){
                JsonObject dateObj = jsonElement.getAsJsonObject();          
                newFoundMap.put(dateObj.get("key_as_string").getAsString(),dateObj.get("doc_count").getAsLong());
                
            }
        } catch (Exception e) {
            LOGGER.error("error",e);
        }   
        
        return newFoundMap;
    
    }
    
    /**
     * Fetch vuln info date ranges.
     *
     * @param ag the ag
     * @param scrollSize the scroll size
     * @param slices the slices
     * @param sliceNo the slice no
     * @param queryBody the query body
     * @param from the from
     * @return the list
     */
    @SuppressWarnings("unchecked")
    private List<String> fetchVulnInfoDateRanges(String ag,int scrollSize,int slices,int sliceNo,String queryBody,LocalDate from){
        //String searchUrl = "http://"+esHost+":"+esPort+"/"+ag+"/vulninfo/_search?scroll=2m&filter_path=hits.total,hits.hits._source,_scroll_id";
        String searchUrl = "/"+ag+"/vulninfo/_search?scroll=2m&filter_path=hits.total,hits.hits._source,_scroll_id";
        StringBuilder request = new StringBuilder();
        request.append("{\"size\":").
        append(scrollSize).
        append(",\"_source\":[\"_firstFound\",\"_closedate\"],").
        append("\"slice\": {\"id\":").
        append(sliceNo).append(",\"max\":").append(slices).append("},").
        append(queryBody).append("}");
        try{
            List<Map<String,Object>> hitsList = scrollAndFetch(searchUrl,request.toString());
            return hitsList.parallelStream().map(obj-> (Map<String,Object>)obj.get("_source")).flatMap( obj-> getDateRange(obj.get("_firstFound"),obj.get("_closedate"),from,DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss[Z]['Z']")).stream()).collect(Collectors.toList());
            
        }catch(Exception e){
            LOGGER.error("error",e);
        }
        return new ArrayList<>();
        
    }
    
    
    private  List<Map<String,Object>> scrollAndFetch(String searchUrl, String requestBody){
        List<Map<String,Object>> hitsList = new ArrayList<>();
        String uri = searchUrl;
        String request = requestBody;
        String searchResponse ;
        JsonParser parser = new JsonParser();  
        JsonObject responeObj ;
        long total ;
        String scrollId ;
        JsonArray hits;
        //String scrollUri ="http://"+esHost+":"+esPort+"/_search/scroll";
        String scrollUri ="/_search/scroll?filter_path=hits.total,hits.hits._source,_scroll_id";
        String scrollRequest = "{\"scroll\":\"2m\",\"scroll_id\":\"%s\"}";
        try{
            do{
                
                //searchResponse = PacHttpUtils.doHttpPost(uri, request);   
                searchResponse = invokeESCall("GET",uri, request);   
                parser = new JsonParser();
                responeObj = parser.parse(searchResponse).getAsJsonObject();
                scrollId = responeObj.get("_scroll_id").getAsString();
                total = responeObj.getAsJsonObject("hits").get("total").getAsLong();
                hits = responeObj.getAsJsonObject("hits").getAsJsonArray("hits");
                hitsList.addAll(new Gson().fromJson(hits,new TypeToken<List<Map<String,Object>>>(){}.getType()));
                uri = scrollUri ;
                request = String.format(scrollRequest, scrollId);
                //System.out.println("SCROLL:"+total+":"+hitsList.size());
                if(hits.size()==0) break;
            }while(total>hitsList.size());
        }catch(Exception e){
            //System.out.println(uri);
            //System.out.println(request);
            LOGGER.error("error",e);
        }
        
        return hitsList;
    }
    
    /**
     * Gets the total doc count.
     *
     * @param ag the ag
     * @param type the type
     * @param queryBody the query body
     * @return the total doc count
     * @throws DataException the data exception
     */
    private long getTotalDocCount(String ag, String type, String queryBody) throws DataException{
        String countUrl = "http://"+esHost+":"+esPort+"/"+ag+"/"+type+"/_count";
        String countResponse = "";
        try {
            countResponse = PacHttpUtils.doHttpPost(countUrl, queryBody);
        } catch (Exception e) {
            throw new DataException(e);
        }   
        JsonParser jsonParser = new JsonParser();
        JsonObject response = jsonParser.parse(countResponse).getAsJsonObject();
        return Double.valueOf(response.get("count").getAsString()).longValue();
       
    }

    /**
     * Gets the date range.
     *
     * @param from the from
     * @param to the to
     * @param excludeBefore the exclude before
     * @param inputFormatter the input formatter
     * @return the date range
     */
    private List<String> getDateRange(Object from, Object to, LocalDate excludeBefore, DateTimeFormatter inputFormatter){
        LocalDate fromDt;
        LocalDate toDt;
        List<String> dateRage = new ArrayList<>();
        if(from!=null){
            fromDt = LocalDateTime.parse(from.toString(),inputFormatter).toLocalDate();
            if(to==null){
                toDt = LocalDate.now();
            }else{
                toDt = LocalDateTime.parse(to.toString(),inputFormatter).toLocalDate();
            }
            DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE;
            while(fromDt.isBefore(toDt)){
                if(!fromDt.isBefore(excludeBefore)){
                    dateRage.add(formatter.format(fromDt));
                }
                fromDt = fromDt.plusDays(1);
             }
        }
        return dateRage;
    }
    
    private List<DateResInfo> getDateRangeWithResourceId(Object from, Object to, LocalDate excludeBefore, DateTimeFormatter inputFormatter,String resourceId){
        LocalDate fromDt;
        LocalDate toDt;
        List<DateResInfo> dateRage = new ArrayList<>();
        if(from!=null){
            fromDt = LocalDateTime.parse(from.toString(),inputFormatter).toLocalDate();
            if(to==null){
                toDt = LocalDate.now();
            }else{
                toDt = LocalDateTime.parse(to.toString(),inputFormatter).toLocalDate();
            }
            DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE;
            while(fromDt.isBefore(toDt)){
                if(!fromDt.isBefore(excludeBefore)){
                    dateRage.add(new DateResInfo(formatter.format(fromDt),resourceId));
                }
                fromDt = fromDt.plusDays(1);
             }
        }
        return dateRage;
    }
  
    /**
     * Fetch assets date ranges for ec 2.
     *
     * @param ag the ag
     * @param from the from
     * @param isAssetsAffected the is assets affected
     * @return the list
     * @throws DataException the data exception
     */
    @SuppressWarnings("unchecked")
    public List<String> fetchAssetsDateRangesForEc2(String ag, LocalDate from) throws DataException {
        List<String> dates = new ArrayList<>();
        //String searchUrl = "http://"+esHost+":"+esPort+"/"+ag+"/ec2/_search?scroll=2m&filter_path=hits.total,hits.hits._source,_scroll_id";
        String searchUrl = "/"+ag+"/ec2/_search?scroll=2m&filter_path=hits.total,hits.hits._source,_scroll_id";
        StringBuilder request = new StringBuilder();
        request.append("{\"query\":{\"range\": {\"discoverydate.keyword\": {\"gte\":\""+from+"\"}}}}");
        long totalCount = getTotalDocCount(ag,"ec2",request.toString());
        //System.out.println("fetchAssetsDateRangesForEc2 Total Count :"+ totalCount );
        if (totalCount > 0) {
            final int scrollSize = totalCount > 10000 ? 10000
                    : (int) (totalCount / 2) + 1;
            
            final int slices = totalCount > scrollSize ? (int) totalCount
                    / scrollSize + 1 : 2;
       
            IntStream.range(0, slices).parallel().forEach(i -> {
                    StringBuilder query = new StringBuilder("{\"size\":").append(scrollSize);
                    query.append(",\"_source\":[\"firstdiscoveredon\",\"discoverydate\"],");
                    query.append("\"slice\": {\"id\":").append(i).append(",\"max\":").append(slices).append("},");
                    query.append(request.toString().substring(1, request.length()));
                    List<String> ec2DatesList = new ArrayList<>();
                    try{
                        List<Map<String,Object>> hitsList = scrollAndFetch(searchUrl,query.toString());
                        ec2DatesList = hitsList.parallelStream().map(obj-> (Map<String,Object>)obj.get("_source")).flatMap( obj-> 
                            getDateRange(obj.get(Constants.FIRST_DISCOVERED_ON),obj.get("discoverydate"),
                                    from,DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ssX"))
                            .stream()).collect(Collectors.toList());
                    }catch(Exception e){
                        LOGGER.error("Error in fetchAssetsDateRangesForEc2",e);
                    }
                    synchronized(dates){
                        dates.addAll(ec2DatesList);
                        //System.out.println(dates.size());
                    }
                 });
        }
        return dates;
    }
    
    /**
     * Fetch assets date ranges on prem.
     *
     * @param ag the ag
     * @param from the from
     * @param isAssetsAffected the is assets affected
     * @return the list
     * @throws DataException the data exception
     */
    @SuppressWarnings("unchecked")
    public List<String> fetchAssetsDateRangesOnPrem(String ag, LocalDate from) throws DataException {
        
        List<String> dates = new ArrayList<>();
        //String searchUrl = "http://"+esHost+":"+esPort+"/"+ag+"/onpremserver/_search?scroll=2m&filter_path=hits.total,hits.hits._source,_scroll_id";
        String searchUrl = "/"+ag+"/onpremserver/_search?scroll=2m&filter_path=hits.total,hits.hits._source,_scroll_id";
        StringBuilder queryBody = new StringBuilder();
        queryBody.append("\"query\":{\"bool\":{\"must\":[{\"script\":{\"script\":\"")
                .append("LocalDate.parse(doc['discoverydate.keyword'].value.substring(0,10)).isAfter(LocalDate.of(").append(from.getYear()+","+from.getMonthValue()+","+from.getDayOfMonth()).append("))")
                .append("|| ( !doc['last_discovered.keyword'].empty  && LocalDate.parse(doc['last_discovered.keyword'].value.substring(0,10)).isAfter(LocalDate.of(").append(from.getYear()+","+from.getMonthValue()+","+from.getDayOfMonth()).append(")))")
                .append("\"}}")
                .append("]}}");
        long totalCount = getTotalDocCount(ag,"onpremserver","{"+queryBody.toString()+"}");
        if (totalCount > 0) {
            final int scrollSize = totalCount > 10000 ? 10000
                    : (int) (totalCount / 2) + 1;
            
            final int slices = totalCount > scrollSize ? (int) totalCount
                    / scrollSize + 1 : 2;
       
            IntStream.range(0, slices)
                .parallel().forEach(i -> {
                    StringBuilder request = new StringBuilder("{\"size\":").append(scrollSize);
                    request.append(",\"_source\":[\"_resourceid\",\"first_discovered\",\"firstdiscoveredon\",\"discoverydate\",\"last_discovered\"],");
                    request.append("\"slice\": {\"id\":").append(i).append(",\"max\":").append(slices).append("},").append(queryBody).append("}");
              
                    List<String> onpremDatesList = new ArrayList<>();
                    try{
                        List<Map<String,Object>> hitsList = scrollAndFetch(searchUrl,request.toString());
                        List<Map<String,Object>> docs = new ArrayList<>();
                        hitsList.parallelStream().forEach(hit -> {
                            Map<String,Object> doc = (Map<String,Object>)hit.get("_source");
                            if(doc.get("first_discovered") != null) {
                                doc.put(Constants.FIRST_DISCOVERED_ON, doc.get("first_discovered"));
                            }
                            //if(doc.get("last_discovered") != null) {
                            //    doc.put("discoverydate", doc.get("last_discovered"));
                           // }
                            synchronized(docs){
                                docs.add(doc);
                            }
                        });
                        
                        onpremDatesList = docs.parallelStream().flatMap(obj-> 
                            getDateRange(obj.get(Constants.FIRST_DISCOVERED_ON).toString().substring(0,19),obj.get("discoverydate").toString().substring(0,19),
                                from,DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))
                                    .stream()).collect(Collectors.toList());
                        
                    }catch(Exception e){
                        LOGGER.error("Error in fetchAssetsDateRangesOnPrem",e);
                    }
                    synchronized(dates){
                        dates.addAll(onpremDatesList);
                    }
                 });
        }
        return dates;
    }
    
    /**
     * Fetch assets date ranges on prem.
     *
     * @param ag the ag
     * @param from the from
     * @param isAssetsAffected the is assets affected
     * @return 
     * @return the list
     * @throws DataException the data exception
     */
    public Map<String,Long> fetchAssetsAffected(String ag, LocalDate from,String severity) throws DataException {
        String queryBody = "\"query\":{\"bool\":{\"must\":[{\"terms\":{\"severitylevel.keyword\":["+severity+"]}}],\"should\":[{\"range\":{\"_closedate\":{\"gte\":\""+from+"\"}}},{\"match\":{\"_status\":\"open\"}}],\"minimum_should_match\":1}}";
        
        long totalCount = getTotalDocCount(ag,"vulninfo","{"+queryBody+"}");
        //System.out.println("Assets Affected Total Count :"+ totalCount );
        List<DateResInfo> dateResouceCompleteList = new ArrayList<>();
        if (totalCount > 0) {
            final int scrollSize = totalCount > 10000 ? 10000
                    : (int) (totalCount / 2) + 1;
            
            final int slices = totalCount > scrollSize ? (int) totalCount
                    / scrollSize + 1 : 2;
       
            IntStream.range(0, slices)
                .parallel().forEach(i -> {
                    List<DateResInfo> datesResourceList = fetchVulnInfoDateRangesPerResource(ag,scrollSize,slices,i,queryBody,from);
                    synchronized(dateResouceCompleteList){
                        dateResouceCompleteList.addAll(datesResourceList);
                    }
                 });
        }
        Map<String,Set<String>> dateResoruceMap = dateResouceCompleteList.parallelStream().collect(Collectors.groupingBy(
                                                                                               obj-> obj.getDate(), Collectors.mapping(obj->obj.getResoruceId(), Collectors.toSet())));
        return dateResoruceMap.entrySet().parallelStream().collect(Collectors.toMap(entry->entry.getKey(), entry-> Long.valueOf(""+entry.getValue().size())));
      
    }
    
    
    /**
     * Fetch vuln info date ranges.
     *
     * @param ag the ag
     * @param scrollSize the scroll size
     * @param slices the slices
     * @param sliceNo the slice no
     * @param queryBody the query body
     * @param from the from
     * @return the list
     */
    @SuppressWarnings("unchecked")
    private List<DateResInfo> fetchVulnInfoDateRangesPerResource(String ag,int scrollSize,int slices,int sliceNo,String queryBody,LocalDate from){
       // String searchUrl = "http://"+esHost+":"+esPort+"/"+ag+"/vulninfo/_search?scroll=2m&filter_path=hits.total,hits.hits._source,_scroll_id";
        String searchUrl = "/"+ag+"/vulninfo/_search?scroll=2m&filter_path=hits.total,hits.hits._source,_scroll_id";
        StringBuilder request = new StringBuilder();
        request.append("{\"size\":").
        append(scrollSize).
        append(",\"_source\":[\"_firstFound\",\"_closedate\",\"_resourceid\"],").
        append("\"slice\": {\"id\":").
        append(sliceNo).append(",\"max\":").append(slices).append("},").
        append(queryBody).append("}");
        try{
            List<Map<String,Object>> hitsList = scrollAndFetch(searchUrl,request.toString());
            return hitsList.parallelStream().map(obj-> (Map<String,Object>)obj.get("_source")).flatMap( obj-> getDateRangeWithResourceId(obj.get("_firstFound"),obj.get("_closedate"),from,DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss[Z]['Z']"),obj.get("_resourceid").toString()).stream()).collect(Collectors.toList());
            
        }catch(Exception e){
            LOGGER.error("error",e);
        }
        return new ArrayList<>();
        
    }
    
    private RestClient getRestClient() {
            RestClientBuilder builder = RestClient.builder(new HttpHost(esHost, esPort));
            builder.setRequestConfigCallback(new RestClientBuilder.RequestConfigCallback() {
                @Override
                public RequestConfig.Builder customizeRequestConfig(RequestConfig.Builder requestConfigBuilder) {
                    return requestConfigBuilder.setConnectionRequestTimeout(0).setSocketTimeout(60000);
                }
            }).setMaxRetryTimeoutMillis(60000);
            return builder.build();
    }

    private String invokeESCall(String method, String endpoint, String payLoad) {
        
        HttpEntity entity = null;
        try {
            if (payLoad != null) {
                entity = new NStringEntity(payLoad, ContentType.APPLICATION_JSON);
            }
            return EntityUtils.toString(getRestClient()
                    .performRequest(method, endpoint, Collections.<String, String>emptyMap(), entity).getEntity());
        } catch (IOException e) {
            LOGGER.error("Error in invokeESCall ", e);
        }
        return null;
    }
}

class DateResInfo {
    String date;
    String resoruceId;
    DateResInfo(String date, String resoruceId){
        this.date = date;
        this.resoruceId = resoruceId;
    }
    public String getDate() {
        return date;
    }
    public void setDate(String date) {
        this.date = date;
    }
    public String getResoruceId() {
        return resoruceId;
    }
    public void setResoruceId(String resoruceId) {
        this.resoruceId = resoruceId;
    }
}