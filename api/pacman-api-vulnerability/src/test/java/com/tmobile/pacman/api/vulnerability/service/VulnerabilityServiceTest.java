/*******************************************************************************
 * Copyright 2018 T Mobile, Inc. or its affiliates. All Rights Reserved.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License.  You may obtain a copy
 * of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
 * License for the specific language governing permissions and limitations under
 * the License.
 ******************************************************************************/
package com.tmobile.pacman.api.vulnerability.service;

import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.hamcrest.CoreMatchers.is;
import static org.hamcrest.CoreMatchers.notNullValue;
import static org.junit.Assert.assertThat;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.anyInt;
import static org.mockito.Matchers.anyList;
import static org.mockito.Matchers.anyMap;
import static org.mockito.Matchers.anyObject;
import static org.mockito.Matchers.anyString;
import static org.powermock.api.mockito.PowerMockito.when;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.MockitoAnnotations;
import org.mockito.Spy;
import org.powermock.modules.junit4.PowerMockRunner;
import org.springframework.http.ResponseEntity;
import org.springframework.test.util.ReflectionTestUtils;

import com.tmobile.pacman.api.commons.Constants;
import com.tmobile.pacman.api.commons.exception.DataException;
import com.tmobile.pacman.api.commons.exception.ServiceException;
import com.tmobile.pacman.api.commons.utils.CommonUtils;
import com.tmobile.pacman.api.commons.utils.ResponseUtils;
import com.tmobile.pacman.api.vulnerability.client.AssetServiceClient;
import com.tmobile.pacman.api.vulnerability.client.ComplianceServiceClient;
import com.tmobile.pacman.api.vulnerability.domain.AssetApi;
import com.tmobile.pacman.api.vulnerability.domain.AssetApiData;
import com.tmobile.pacman.api.vulnerability.domain.AssetCount;
import com.tmobile.pacman.api.vulnerability.domain.AssetCountByAppEnvDTO;
import com.tmobile.pacman.api.vulnerability.domain.AssetCountDTO;
import com.tmobile.pacman.api.vulnerability.domain.AssetCountData;
import com.tmobile.pacman.api.vulnerability.domain.Request;
import com.tmobile.pacman.api.vulnerability.domain.ResponseWithOrder;
import com.tmobile.pacman.api.vulnerability.domain.TrendNote;
import com.tmobile.pacman.api.vulnerability.repository.VulnerabilityRepository;
import com.tmobile.pacman.api.vulnerability.repository.VulnerabilityTrendGenerator;

@RunWith(PowerMockRunner.class)
public class VulnerabilityServiceTest {

	@InjectMocks
	VulnerabilityService vulnerabilityService;

	@Mock
	VulnerabilityRepository vulnerabilityRepository;

	@Mock
	AssetServiceClient assetServiceClient;

	@Mock
	VulnerabilityTrendGenerator vulnTrendGenerator;

	@Mock
	ComplianceServiceClient complianceServiceClient;

	@Mock
	CommonUtils commonUtils;

	@Before
	public void setUp() {
		MockitoAnnotations.initMocks(this);

		AssetApi assetApi = new AssetApi();
		AssetApiData data = new AssetApiData();

		List<AssetCountDTO> ttypes = new ArrayList<>();
		AssetCountDTO tt = new AssetCountDTO();
		tt.setType("ec2");
		ttypes.add(tt);
		tt = new AssetCountDTO();
		tt.setType("onpremserver");
		ttypes.add(tt);

		data.setTargettypes(ttypes.toArray(new AssetCountDTO[ttypes.size()]));
		assetApi.setData(data);

		when(assetServiceClient.getTargetTypeList(anyString(), anyObject())).thenReturn(assetApi);
	}

	@Test
	public void getVulnerabilitiesDetailsTest() throws Exception {

		List<Map<String, Object>> vulnerabilitiesData = new ArrayList<>();

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		when(vulnerabilityRepository.getAssetsAffectedCount(anyString(), anyObject(), anyString()))
				.thenReturn(new HashMap<>());
		when(vulnerabilityRepository.getAllVulnerabilities(anyObject())).thenReturn(vulnerabilitiesData);
		assertThat(vulnerabilityService.getVulnerabilitiesDetails("ag", null), is(notNullValue()));

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "test");
		assertThat(vulnerabilityService.getVulnerabilitiesDetails("ag", null), is(notNullValue()));

		Map<String, Object> vuln = new HashMap<>();
		vuln.put("qid", "123");
		vuln.put("assetsAffected", 1);
		vuln.put(Constants.TITLE, "test");
		vuln.put(Constants.SEVEITY_LEVEL, "3");
		vuln.put(Constants.CATEGORY, "test");
		vuln.put(Constants.VULN_TYPE, "type");
		vuln.put(Constants.PATCHABLE, "1");
		vulnerabilitiesData.add(vuln);

		vuln = new HashMap<>();
		vuln.put("qid", "456");
		vuln.put("assetsAffected", 2);
		vuln.put(Constants.TITLE, "test");
		vuln.put(Constants.SEVEITY_LEVEL, "5");
		vuln.put(Constants.CATEGORY, "test");
		vuln.put(Constants.VULN_TYPE, "type");
		vuln.put(Constants.PATCHABLE, "0");
		vulnerabilitiesData.add(vuln);

		vuln = new HashMap<>();
		vuln.put("qid", "789");
		vuln.put("assetsAffected", 2);
		vuln.put(Constants.TITLE, "test");
		vuln.put(Constants.SEVEITY_LEVEL, "5");
		vuln.put(Constants.CATEGORY, "test");
		vuln.put(Constants.VULN_TYPE, "type");
		vulnerabilitiesData.add(vuln);

		Map<String, Long> assetsAffected = new HashMap<String, Long>();
		assetsAffected.put("123", 10L);
		assetsAffected.put("456", 10L);
		assetsAffected.put("789", 10L);

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2,onpremserver");
		when(vulnerabilityRepository.getAssetsAffectedCount(anyString(), anyObject(), anyString()))
				.thenReturn(assetsAffected);
		when(vulnerabilityRepository.getAllVulnerabilities(anyObject())).thenReturn(vulnerabilitiesData);
		assertThat(vulnerabilityService.getVulnerabilitiesDetails("ag", null), is(notNullValue()));
	}

	@Test
	public void getVulnerabilitiesDetailsTest_Exception() throws Exception {

		when(vulnerabilityRepository.getAssetsAffectedCount(anyString(), anyObject(), anyString()))
				.thenReturn(new HashMap<>());
		when(vulnerabilityRepository.getAllVulnerabilities(anyObject())).thenThrow(new DataException());
		assertThatThrownBy(() -> vulnerabilityService.getVulnerabilitiesDetails("ag", null))
				.isInstanceOf(Exception.class);
	}

	@Test
	public void getVulnerabilitySummaryTest() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "test");
		assertThat(vulnerabilityService.getVulnerabilitySummary("ag", "3,4,5"), is(notNullValue()));

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		when(vulnerabilityRepository.getUniqueHost(anyString(), anyString())).thenReturn(new HashMap<String, Object>());
		when(vulnerabilityRepository.getVulnInfo(anyString(), anyString())).thenReturn(new HashMap<String, Object>());
		when(vulnerabilityRepository.getUniqueApp(anyString())).thenReturn(new HashMap<String, Object>());

		AssetCount totalAssets = new AssetCount();
		AssetCountData data = new AssetCountData();

		AssetCountByAppEnvDTO assetCount_Count = new AssetCountByAppEnvDTO();
		assetCount_Count.setType("onpremserver");
		assetCount_Count.setCount("1");

		List<AssetCountByAppEnvDTO> assetAppEnvDTOs = new ArrayList<AssetCountByAppEnvDTO>();
		assetAppEnvDTOs.add(assetCount_Count);
		data.setAssetcount(assetAppEnvDTOs.toArray(new AssetCountByAppEnvDTO[assetAppEnvDTOs.size()]));
		totalAssets.setData(data);

		List<LinkedHashMap<String, Object>> response = new ArrayList<>();
		LinkedHashMap<String, Object> obj = new LinkedHashMap<>();
		obj.put("assetsScanned", 5);
		obj.put("failed", 2);
		obj.put("passed", 2);
		response.add(obj);
		Map<String, Object> responseMap = new HashMap<>();
		responseMap.put("response", response);
		ResponseEntity<Object> nonCompliancePolicyRuleresponse = ResponseUtils.buildSucessResponse(responseMap);

		when(complianceServiceClient.getNonCompliancePolicyByRule(any(Request.class)))
				.thenReturn(nonCompliancePolicyRuleresponse);
		when(vulnerabilityRepository.getTotalQualysHostCount(anyString(), anyString())).thenReturn(1L);
		ReflectionTestUtils.setField(vulnerabilityService, "vulnSummarySeverity", "3");

		Map<String, Object> vulnSummary = new HashMap<>();
		List<Map<String, Object>> severityInfo = new ArrayList<>();
		Map<String, Object> severity = new HashMap<>();
		severity.put(Constants.SEVEITY_LEVEL, 3);
		severity.put(Constants.COUNT, 2);
		severity.put(Constants.VULN_COUNT, 2);
		severityInfo.add(severity);
		severity = new HashMap<>();
		severity.put(Constants.SEVEITY_LEVEL, 4);
		severity.put(Constants.COUNT, 2);
		severity.put(Constants.VULN_COUNT, 2);
		severityInfo.add(severity);
		severity = new HashMap<>();
		severity.put(Constants.SEVEITY_LEVEL, 5);
		severity.put(Constants.COUNT, 2);
		severity.put(Constants.VULN_COUNT, 2);
		severityInfo.add(severity);

		vulnSummary.put("severityInfo", severityInfo);
		assertThat(vulnerabilityService.getVulnerabilitySummary("ag", "3,4,5"), is(notNullValue()));

		Map<String, Object> uniqueHost = new HashMap<>();
		uniqueHost.put("total", 10);
		uniqueHost.put("3", 1);
		Map<String, Object> vulnInfo = new HashMap<>();
		Map<String, Object> vulnInfoMap = new HashMap<>();
		vulnInfoMap.put(Constants.VULN_COUNT, 2);
		vulnInfoMap.put(Constants.UNIQUE_VULN_COUNT, 2);
		vulnInfo.put("total", 10);
		vulnInfo.put("3", vulnInfoMap);
		Map<String, Object> uniqueApp = new HashMap<>();
		uniqueApp.put("3", 1);
		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2,onpremserver");
		when(vulnerabilityRepository.getUniqueHost(anyString(), anyString())).thenReturn(uniqueHost);
		when(vulnerabilityRepository.getVulnInfo(anyString(), anyString())).thenReturn(vulnInfo);
		when(vulnerabilityRepository.getUniqueApp(anyString())).thenReturn(uniqueApp);

		when(complianceServiceClient.getNonCompliancePolicyByRule(any(Request.class)))
				.thenReturn(nonCompliancePolicyRuleresponse);
		// when(complianceService.getRulecompliance(any(Request.class))).thenReturn(responseWithOrder);
		when(assetServiceClient.getTotalAssetsCount(anyString(), anyString(), anyString())).thenReturn(totalAssets);
		when(vulnerabilityRepository.getTotalQualysHostCount(anyString(), anyString())).thenReturn(1L);
		ReflectionTestUtils.setField(vulnerabilityService, "vulnSummarySeverity", "3");

		vulnSummary.put("severityInfo", severityInfo);

		assertThat(vulnerabilityService.getVulnerabilitySummary("ag", "3"), is(notNullValue()));

	}

	/**
	 * commenting this test case as we moved this method to the compliance service.
	 * 
	 * @throws Exception
	 */
	@Test
	public void getVulnerabilitySummaryTest_Exception() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		when(vulnerabilityRepository.getUniqueHost(anyString(), anyString())).thenReturn(new HashMap<String, Object>());
		when(vulnerabilityRepository.getVulnInfo(anyString(), anyString())).thenReturn(new HashMap<String, Object>());
		when(vulnerabilityRepository.getUniqueApp(anyString())).thenReturn(new HashMap<String, Object>());

		ReflectionTestUtils.setField(vulnerabilityService, "vulnSummarySeverity", "3");

		ResponseWithOrder responseWithOrder = new ResponseWithOrder();
		List<LinkedHashMap<String, Object>> response = new ArrayList<>();
		LinkedHashMap<String, Object> obj = new LinkedHashMap<>();
		obj.put("assetsScanned", 1);
		obj.put("passed", 1);
		response.add(obj);
		responseWithOrder.setResponse(response);

		Map<String, Object> responseTest = new HashMap();
		responseTest.put(Constants.DATA_KEY, responseWithOrder);
		responseTest.put(Constants.STATUS_KEY, Constants.STATUS_SUCCESS);
		ResponseEntity<Object> nonCompliancePolicyRuleresponse = ResponseEntity.ok().body((Object) responseTest);

		// when(complianceServiceClient.getNonCompliancePolicyByRule(any(Request.class))).thenReturn(nonCompliancePolicyRuleresponse);
		// when(complianceServiceClient.getNonCompliancePolicyByRule(any(Request.class))).thenThrow(new
		// ServiceException());
		// assertThatThrownBy(
		// () ->
		// vulnerabilityService.getVulnerabilitySummary("ag","3,4,5")).isInstanceOf(ServiceException.class);
	}

	@Test
	public void getVulnerabilityByAppAndEnvTest() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		when(vulnerabilityRepository.getVulnerabilyAcrossAppAndEnv(anyString(), anyObject(), anyString(), anyString(),
				anyString())).thenReturn(new ArrayList<>());
		assertThat(vulnerabilityService.getVulnerabilityByAppAndEnv("ag", "filter", "app"), is(notNullValue()));

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "test");
		assertThat(vulnerabilityService.getVulnerabilityByAppAndEnv("ag", "filter", "app").size(), is(0));
	}

	@Test
	public void getVulnerabilityTrendTest() throws Exception {

		when(vulnerabilityRepository.getVulnerabilityTrend(anyString(), anyObject(), anyObject(), anyObject()))
				.thenReturn(new ArrayList<>());
		assertThat(vulnerabilityService.getVulnerabilityTrend("ag", null, new Date(), new Date()), is(notNullValue()));
	}

	/*@Test
	public void getVulnerabilityNewOpenTrendTest() throws Exception {

		when(vulnTrendGenerator.generateTrend(anyString(), anyString(), anyObject())).thenReturn(new ArrayList<>());
		assertThat(vulnerabilityService.getVulnerabilityNewOpenTrend("ag", "sev", new Date()), is(notNullValue()));
	}*/

	@Test
	public void getVulnerabilitiesDistributionTest() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		when(vulnerabilityRepository.getVulnerabilitiesDistribution(anyString(), anyString()))
				.thenReturn(new ArrayList<>());
		assertThat(vulnerabilityService.getVulnerabilitiesDistribution("ag"), is(notNullValue()));

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "test");
		assertThat(vulnerabilityService.getVulnerabilitiesDistribution("ag").size(), is(0));
	}

	/*
	 * @SuppressWarnings("static-access")
	 * 
	 * @Test public void filterMatchingCollectionElementsTest() throws Exception {
	 * 
	 * when(commonUtils.filterMatchingCollectionElements(anyObject(), anyObject(),
	 * anyObject())).thenReturn(new Object());
	 * assertThat(vulnerabilityService.filterMatchingCollectionElements(new
	 * ArrayList<>(),"sev",true), is(notNullValue())); }
	 */

	@Test
	public void getVulnerabilitysummaryByResourceIdTest() throws Exception {

		when(vulnerabilityRepository.getVulnerabilitysummaryByResourceId(anyString())).thenReturn(new HashMap<>());
		assertThat(vulnerabilityService.getVulnerabilitysummaryByResourceId("id"), is(notNullValue()));
	}

	@Test
	public void getVulnerabilityDetailsByResourceIdTest() throws Exception {

		List<Map<String, Object>> vulnerabilitiesData = new ArrayList<>();

		Map<String, Object> vuln = new HashMap<>();
		vuln.put("qid", "123");
		vuln.put("assetsAffected", 1);
		vuln.put(Constants.TITLE, "test");
		vuln.put(Constants.SEVEITY_LEVEL, "3");
		vuln.put(Constants.CATEGORY, "test");
		vuln.put(Constants.VULN_TYPE, "type");
		vuln.put(Constants.PATCHABLE, "1");
		vulnerabilitiesData.add(vuln);

		when(vulnerabilityRepository.getVulnerabilityDetailsByResourceId(anyString())).thenReturn(vulnerabilitiesData);
		assertThat(vulnerabilityService.getVulnerabilityDetailsByResourceId("id"), is(notNullValue()));

		vuln = new HashMap<>();
		vuln.put("qid", "123");
		vuln.put("assetsAffected", 1);
		vulnerabilitiesData.add(vuln);

		when(vulnerabilityRepository.getVulnerabilityDetailsByResourceId(anyString())).thenReturn(vulnerabilitiesData);
		assertThatThrownBy(() -> vulnerabilityService.getVulnerabilityDetailsByResourceId("id"))
				.isInstanceOf(Exception.class);
	}

	@Test
	public void getAgingSummaryTest() throws Exception {

		when(vulnerabilityRepository.getAgingSummary(anyString())).thenReturn(new ArrayList<>());
		assertThat(vulnerabilityService.getAgingSummary("ag"), is(notNullValue()));
	}

	@Test
	public void getVulnerabilityByQidTest() throws Exception {

		Map<String, Object> vuln = new HashMap<>();
		vuln.put("qid", "123");
		vuln.put("vulntype", "type");
		vuln.put("severitylevel", "3");
		vuln.put("title", "test");
		vuln.put("category", "");
		vuln.put("lastservicemodificationdatetime", "1234");
		vuln.put("publisheddatetime", "123");
		vuln.put("patchable", "1");
		Map<String, Object> softwarelist = new HashMap<>();
		List<Map<String, Object>> softwares = new ArrayList<>();
		Map<String, Object> innerMap = new HashMap<>();
		innerMap.put("test", "test");
		innerMap.put("test", "test");
		softwares.add(innerMap);
		softwarelist.put("software", softwares);
		vuln.put("softwarelist", softwarelist);
		Map<String, Object> vendorreferencelist = new HashMap<>();
		List<Map<String, Object>> vendorreference = new ArrayList<>();
		vendorreference.add(innerMap);
		vendorreferencelist.put("vendorreference", vendorreference);
		vuln.put("vendorreferencelist", vendorreferencelist);
		vuln.put("diagnosis", "test");
		vuln.put("consequence", "test");
		vuln.put("solution", "test");
		Map<String, Object> bugtraqlist = new HashMap<>();
		List<Map<String, Object>> bugtraq = new ArrayList<>();
		bugtraq.add(innerMap);
		bugtraqlist.put("vendorreference", bugtraq);
		vuln.put("bugtraqlist", bugtraqlist);
		vuln.put("pciflag", 0);
		Map<String, Object> pcireasons = new HashMap<>();
		List<Map<String, Object>> pcireason = new ArrayList<>();
		pcireason.add(innerMap);
		pcireasons.put("pcireason", pcireason);
		vuln.put("pcireasons", pcireasons);
		Map<String, Object> authtypelist = new HashMap<>();
		List<Map<String, Object>> authtype = new ArrayList<>();
		authtype.add(innerMap);
		authtypelist.put("authtype", authtype);
		Map<String, Object> discovery = new HashMap<>();
		discovery.put("authtypelist", authtypelist);
		discovery.put("additionalinfo", "Patch Available");
		vuln.put("discovery", discovery);
		vuln.put("supportedmodules", "test");
		Map<String, Object> cvelist = new HashMap<>();
		List<Map<String, Object>> cve = new ArrayList<>();
		cve.add(innerMap);
		cvelist.put("cve", cve);
		vuln.put("cvelist", cvelist);
		Map<String, Object> cvss = new HashMap<>();
		cvss.put("base", 1);
		cvss.put("temporal", 1);
		vuln.put("cvssv3", cvss);
		Map<String, Object> access = new HashMap<>();
		access.put("vector", 1);
		cvss.put("access", access);
		vuln.put("cvss", cvss);

		when(vulnerabilityRepository.getVulnerabilityByQid(anyString())).thenReturn(vuln);
		assertThat(vulnerabilityService.getVulnerabilityByQid("id"), is(notNullValue()));

		vuln = new HashMap<>();
		discovery = new HashMap<>();
		discovery.put("additionalinfo", "test");
		vuln.put("discovery", discovery);
		vuln.put("pciflag", 1);

		when(vulnerabilityRepository.getVulnerabilityByQid(anyString())).thenReturn(vuln);
		assertThat(vulnerabilityService.getVulnerabilityByQid("id"), is(notNullValue()));

		when(vulnerabilityRepository.getVulnerabilityByQid(anyString())).thenReturn(new HashMap<>());
		assertThat(vulnerabilityService.getVulnerabilityByQid("id"), is(notNullValue()));
	}

	@Test
	public void getHighestLowestPerformersTest() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "test");
		when(vulnerabilityRepository.fetchOrgInfoForApps()).thenReturn(fetchOrgInfoForApps());
		assertThat(vulnerabilityService.getHighestLowestPerformers("ag", null, "org").size(), is(0));

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		when(vulnerabilityRepository.getAppsBySeverity(anyString(), anyString(), anyString()))
				.thenReturn(new HashMap<>());
		when(vulnerabilityRepository.fetchOrgInfoForApps()).thenReturn(fetchOrgInfoForApps());
		assertThat(vulnerabilityService.getHighestLowestPerformers("ag", null, "org").size(), is(0));

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2,onpremserver");
		Map<String, Long> apps = new HashMap<>();
		apps.put("app1", 1L);
		apps.put("app2", 2L);
		apps.put("app3", 3L);
		when(vulnerabilityRepository.getAppsBySeverity(anyString(), anyString(), anyString())).thenReturn(apps);
		when(vulnerabilityRepository.fetchOrgInfoForApps()).thenReturn(fetchOrgInfoForApps());
		assertThat(vulnerabilityService.getHighestLowestPerformers("ag", "3", "org").size(), is(2));

		when(vulnerabilityRepository.getVulnerabilyAcrossAppAndEnv(anyString(), anyString(), anyString(), anyString(),
				anyString())).thenReturn(getVulnByApp());
		assertThat(vulnerabilityService.getHighestLowestPerformers("ag", "3", Constants.APPLICATION).size(), is(2));

		when(vulnerabilityRepository.getVulnerabilyAcrossAppAndEnv(anyString(), anyString(), anyString(), anyString(),
				anyString())).thenReturn(getVulnByEnv());
		assertThat(vulnerabilityService.getHighestLowestPerformers("ag", "3", Constants.ENVIRONMENT).size(), is(2));
	}

	@Test
	public void getHighestLowestPerformersTest_Exception() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		when(vulnerabilityRepository.getAppsBySeverity(anyString(), anyString(), anyString()))
				.thenReturn(new HashMap<>());
		when(vulnerabilityRepository.fetchOrgInfoForApps()).thenThrow(new Exception());
		assertThat(vulnerabilityService.getHighestLowestPerformers("ag", "3", "org").size(), is(0));

		when(vulnerabilityRepository.getAppsBySeverity(anyString(), anyString(), anyString()))
				.thenThrow(new Exception());
		assertThat(vulnerabilityService.getHighestLowestPerformers("ag", "3", "org").size(), is(0));

		when(vulnerabilityRepository.getVulnerabilyAcrossAppAndEnv(anyString(), anyString(), anyString(), anyString(),
				anyString())).thenThrow(new Exception());
		assertThat(vulnerabilityService.getHighestLowestPerformers("ag", "3", Constants.APPLICATION).size(), is(0));
		assertThat(vulnerabilityService.getHighestLowestPerformers("ag", "3", Constants.ENVIRONMENT).size(), is(0));
	}

	@Test
	public void getDistributionSummaryByInfraTypeTest() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2,onpremserver");
		Map<String, Object> infraInfo = new HashMap<>();
		infraInfo.put(Constants.TOTAL_VULN_ASSETS, 1);
		infraInfo.put(Constants.VULNEREBILITIES, 1);
		infraInfo.put(Constants.UNIQUE_VULN_COUNT, 1);
		when(vulnerabilityRepository.getDistributionSummaryByInfraType(anyString(), anyString(), anyString()))
				.thenReturn(infraInfo);
		assertThat(vulnerabilityService.getDistributionSummaryByInfraType("ag", null), is(notNullValue()));

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		when(vulnerabilityRepository.getDistributionSummaryByInfraType(anyString(), anyString(), anyString()))
				.thenReturn(infraInfo);
		assertThat(vulnerabilityService.getDistributionSummaryByInfraType("ag", "3"), is(notNullValue()));
	}

	@Test
	public void getDistributionSummaryByInfraTypeTest_Exception() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		when(vulnerabilityRepository.getDistributionSummaryByInfraType(anyString(), anyString(), anyString()))
				.thenThrow(new DataException());
		assertThatThrownBy(() -> vulnerabilityService.getDistributionSummaryByInfraType("ag", "3"))
				.isInstanceOf(ServiceException.class);
	}

	@Test
	public void getDistributionSummaryByEnvTest() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2,onpremserver");

		Map<String, Long> prodInfo = new HashMap<>();
		prodInfo.put("totalVulnerableAssets", 1L);
		prodInfo.put(Constants.VULNEREBILITIES, 1L);
		prodInfo.put("uniqueVulnCount", 1L);

		Map<String, Long> nonProdInfo = new HashMap<>();
		nonProdInfo.put("totalVulnerableAssets", 1L);
		nonProdInfo.put(Constants.VULNEREBILITIES, 1L);
		nonProdInfo.put("uniqueVulnCount", 1L);

		when(vulnerabilityRepository.getProdInfoByEnv(anyString(), anyString())).thenReturn(prodInfo);
		when(vulnerabilityRepository.getNonProdInfoByEnv(anyString(), anyString())).thenReturn(nonProdInfo);
		assertThat(vulnerabilityService.getDistributionSummaryByEnv("ag", "3"), is(notNullValue()));

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");

		prodInfo = new HashMap<>();
		prodInfo.put("totalVulnerableAssets", 0L);
		prodInfo.put(Constants.VULNEREBILITIES, 0L);
		prodInfo.put("uniqueVulnCount", 0L);

		nonProdInfo = new HashMap<>();
		nonProdInfo.put("totalVulnerableAssets", 0L);
		nonProdInfo.put(Constants.VULNEREBILITIES, 0L);
		nonProdInfo.put("uniqueVulnCount", 0L);

		when(vulnerabilityRepository.getProdInfoByEnv(anyString(), anyString())).thenReturn(prodInfo);
		when(vulnerabilityRepository.getNonProdInfoByEnv(anyString(), anyString())).thenReturn(nonProdInfo);
		assertThat(vulnerabilityService.getDistributionSummaryByEnv("ag", ""), is(notNullValue()));
	}

	@Test
	public void getDistributionSummaryByEnvTest_Exception() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		Map<String, Long> prodInfo = new HashMap<>();
		prodInfo.put("totalVulnerableAssets", 1L);
		prodInfo.put("uniqueVulnCount", 1L);

		Map<String, Long> nonProdInfo = new HashMap<>();
		nonProdInfo.put("totalVulnerableAssets", 1L);
		nonProdInfo.put(Constants.VULNEREBILITIES, 1L);
		nonProdInfo.put("uniqueVulnCount", 1L);

		when(vulnerabilityRepository.getProdInfoByEnv(anyString(), anyString())).thenReturn(prodInfo);
		when(vulnerabilityRepository.getNonProdInfoByEnv(anyString(), anyString())).thenReturn(nonProdInfo);
		assertThatThrownBy(() -> vulnerabilityService.getDistributionSummaryByEnv("ag", "3"))
				.isInstanceOf(ServiceException.class);
	}

	@Test
	public void getDistributionSummaryByVulnTypeTest() throws Exception {

		when(vulnerabilityRepository.getDistributionSummaryByVulnType(anyString(), anyString()))
				.thenReturn(new ArrayList<>());
		assertThat(vulnerabilityService.getDistributionSummaryByVulnType("ag", "3"), is(notNullValue()));

		when(vulnerabilityRepository.getDistributionSummaryByVulnType(anyString(), anyString()))
				.thenReturn(new ArrayList<>());
		assertThat(vulnerabilityService.getDistributionSummaryByVulnType("ag", null), is(notNullValue()));
	}

	@Test
	public void getRemediationActionsSummaryTest() throws Exception {

		Map<String, Object> qids = new HashMap<>();
		qids.put("123~title~OS", 2);
		qids.put("123~EOL/Obsolete~Infra", 2);
		qids.put("11925~title~Infra", 2);
		qids.put("370914~title~Infra", 2);
		qids.put("123~Java Debug Wire Protocol~Infra", 0);
		qids.put("123~Java JMX Server Insecure Configuration~Infra", 2);
		qids.put("123~Java~Infra", 2);
		qids.put("123~title~Infra", 2);
		when(vulnerabilityRepository.getAllQidByAG(anyString(), anyString())).thenReturn(qids);
		assertThat(vulnerabilityService.getRemediationActionsSummary("ag", null), is(notNullValue()));
	}

	private List<Map<String, Object>> getApps() {

		List<Map<String, Object>> vulnApplications = new ArrayList<>();
		List<Map<String, Object>> severityInfo = new ArrayList<>();

		Map<String, Object> severity = new HashMap<>();
		severity.put(Constants.SEVERITY, "S3");
		severity.put(Constants.COUNT, 3);
		severity.put("days", 3);
		severityInfo.add(severity);
		severity = new HashMap<>();
		severity.put(Constants.SEVERITY, "S4");
		severity.put(Constants.COUNT, 4);
		severity.put("days", 4);
		severityInfo.add(severity);
		severity = new HashMap<>();
		severity.put(Constants.SEVERITY, "S5");
		severity.put(Constants.COUNT, 5);
		severity.put("days", 5);
		severityInfo.add(severity);

		Map<String, Object> vulnApp = new HashMap<>();
		vulnApp.put("application", "app1");
		vulnApp.put(Constants.SEV_INFO, severityInfo);
		vulnApplications.add(vulnApp);

		vulnApp = new HashMap<>();
		vulnApp.put("application", "app2");
		vulnApp.put(Constants.SEV_INFO, severityInfo);
		vulnApplications.add(vulnApp);

		vulnApp = new HashMap<>();
		vulnApp.put("application", "app3");
		vulnApp.put(Constants.SEV_INFO, severityInfo);
		vulnApplications.add(vulnApp);
		return vulnApplications;
	}

	private List<Map<String, Object>> getVulnByApp() {

		List<Map<String, Object>> vulnEnvironments = new ArrayList<>();
		List<Map<String, Object>> severityInfo = new ArrayList<>();

		Map<String, Object> severity = new HashMap<>();
		severity.put("severitylevel", "3");
		severity.put("vulnInstanceCount", 3);
		severityInfo.add(severity);
		severity = new HashMap<>();

		Map<String, Object> vulnApp = new HashMap<>();
		vulnApp.put("application", "app1");
		vulnApp.put(Constants.SEV_INFO, severityInfo);
		vulnEnvironments.add(vulnApp);

		vulnApp = new HashMap<>();
		vulnApp.put("application", "app2");
		vulnApp.put(Constants.SEV_INFO, severityInfo);
		vulnEnvironments.add(vulnApp);

		return vulnEnvironments;
	}

	private List<Map<String, Object>> getVulnByEnv() {

		List<Map<String, Object>> vulnEnvironments = new ArrayList<>();
		List<Map<String, Object>> severityInfo = new ArrayList<>();

		Map<String, Object> severity = new HashMap<>();
		severity.put("severitylevel", "3");
		severity.put("vulnInstanceCount", 3);
		severityInfo.add(severity);
		severity = new HashMap<>();

		Map<String, Object> vulnApp = new HashMap<>();
		vulnApp.put("environment", "env1");
		vulnApp.put(Constants.SEV_INFO, severityInfo);
		vulnEnvironments.add(vulnApp);

		vulnApp = new HashMap<>();
		vulnApp.put("environment", "env2");
		vulnApp.put(Constants.SEV_INFO, severityInfo);
		vulnEnvironments.add(vulnApp);

		return vulnEnvironments;
	}

	private List<Map<String, Object>> fetchOrgInfoForApps() {
		List<Map<String, Object>> apps = new ArrayList<>();
		Map<String, Object> app = new HashMap<>();
		app.put("appTag", "app1");
		app.put("list", "[{\"mgmntLevel\":\"2\",\"name\":\"svp1\"},{\"mgmntLevel\":\"3\",\"name\":\"vp1\"}]");
		apps.add(app);

		app = new HashMap<>();
		app.put("appTag", "app2");
		app.put("list", "[{\"mgmntLevel\":\"2\",\"name\":\"svp2\"},{\"mgmntLevel\":\"3\",\"name\":\"vp2\"}]");
		apps.add(app);

		app = new HashMap<>();
		app.put("appTag", "app3");
		app.put("list", "[{\"mgmntLevel\":\"4\",\"name\":\"sdir4\"}]");
		apps.add(app);

		app = new HashMap<>();
		app.put("appTag", "app5");
		app.put("list", "[{\"mgmntLevel\":\"2\",\"name\":\"svp5\"},{\"mgmntLevel\":\"5\",\"name\":\"dir5\"}]");
		apps.add(app);

		return apps;
	}

	@Test
	public void createTrendAnnotationTest() throws Exception {

		when(vulnerabilityRepository.createTrendAnnotation(any(TrendNote.class))).thenReturn(true);
		assertThat(vulnerabilityService.createTrendAnnotation(new TrendNote()), is(true));
	}

	@Test
	public void getTrendAnnotationTest() throws Exception {

		List<Map<String, Object>> annotations = new ArrayList<>();
		Map<String, Object> annotation = new HashMap<>();
		annotation.put("ag", "ag");
		annotations.add(annotation);

		annotation = new HashMap<>();
		annotation.put("ag", "");
		annotations.add(annotation);

		when(vulnerabilityRepository.getTrendAnnotations(anyString(), any(Date.class))).thenReturn(annotations);
		assertThat(vulnerabilityService.getTrendAnnotations("ag", new Date()).size(), is(2));
	}

	@Test
	public void deleteTrendAnnotationTest() throws Exception {

		when(vulnerabilityRepository.deleteTrendAnnotation(anyString())).thenReturn(true);
		assertThat(vulnerabilityService.deleteTrendAnnotation("noteId"), is(true));
	}

	@Test
	public void getVulnerabilitySummaryByAssetsTest() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2,onpremserver");
		when(vulnerabilityRepository.getRunningInstancesCount(anyString(), anyString())).thenReturn(10L);
		when(vulnerabilityRepository.getExemptedByRuleCount(anyString(), anyString())).thenReturn(1L);

		ResponseWithOrder responseWithOrder = new ResponseWithOrder();
		List<LinkedHashMap<String, Object>> response = new ArrayList<>();
		LinkedHashMap<String, Object> obj = new LinkedHashMap<>();
		obj.put("assetsScanned", 5);
		obj.put("failed", 2);
		obj.put("passed", 2);
		response.add(obj);
		responseWithOrder.setResponse(response);
		Map<String, Object> responseMap = new HashMap<>();
		responseMap.put("response", response);
		ResponseEntity<Object> nonCompliancePolicyRuleresponse = ResponseUtils.buildSucessResponse(responseMap);

		when(complianceServiceClient.getNonCompliancePolicyByRule(any(Request.class)))
				.thenReturn(nonCompliancePolicyRuleresponse);
		// when(complianceServiceClient.getRulecompliance(any(Request.class))).thenReturn(responseWithOrder);

		Map<String, Object> compliant = new HashMap<>();
		compliant.put("S3", 2);
		compliant.put("S4", 2);

		Map<String, Object> nonCompliant = new HashMap<>();
		nonCompliant.put("S3", 3);
		nonCompliant.put("S4", 2);
		nonCompliant.put("S5", 1);

		when(vulnerabilityRepository.getNonCompliantResourceIds(anyString())).thenReturn(new ArrayList<>());
		when(vulnerabilityRepository.getCompliantHostsBySeverity(anyString())).thenReturn(compliant);
		when(vulnerabilityRepository.getUniqueHostBySeverity(anyString(), anyString())).thenReturn(nonCompliant);

		assertThat(vulnerabilityService.getVulnerabilitySummaryByAssets("ag").get(Constants.COUNT), is(20L));
	}

	@Test
	public void getVulnerabilitySummaryByAssetsTest_Exception() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		when(vulnerabilityRepository.getRunningInstancesCount(anyString(), anyString())).thenThrow(new DataException());
		assertThatThrownBy(() -> vulnerabilityService.getVulnerabilitySummaryByAssets("ag"))
				.isInstanceOf(ServiceException.class);
	}

	/*@Test
	public void getVulnerabilityAssetsTrendTest() throws Exception {

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2,onpremserver");
		List<String> assets = Arrays.asList("2018-10-01");
		when(vulnTrendGenerator.fetchAssetsDateRangesForEc2(anyString(), any(LocalDate.class))).thenReturn(assets);
		when(vulnTrendGenerator.fetchAssetsDateRangesOnPrem(anyString(), any(LocalDate.class))).thenReturn(assets);

		assertThat(vulnerabilityService.getVulnerabilityAssetsTrend("ag", "3", new Date()).get(0).get("totalAssets"),
				is(2L));

		when(vulnTrendGenerator.fetchAssetsDateRangesForEc2(anyString(), any(LocalDate.class)))
				.thenThrow(new DataException());
		when(vulnTrendGenerator.fetchAssetsDateRangesOnPrem(anyString(), any(LocalDate.class)))
				.thenThrow(new DataException());

		assertThat(vulnerabilityService.getVulnerabilityAssetsTrend("ag", "3", new Date()).size(), is(0));
	}*/

	@SuppressWarnings("unchecked")
	@Test
	public void vulnerabilityAssetCountTest() throws Exception {

		Map<String, String> mustFilterMap = new HashMap<>();
		mustFilterMap.put("latest", "true");
		mustFilterMap.put("entity", "true");
		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		when(vulnerabilityRepository.vulnerabilityAssetsCount(anyString(), anyString(), anyMap(), anyInt(), anyInt(),
				anyMap())).thenReturn(5);
		assertThat(vulnerabilityService.vulnerabilityAssetCount("ag", mustFilterMap, "pac", "pro", 0, 0), is(5));
	}

	@SuppressWarnings("unchecked")
	@Test
	public void getAllVulnerabilitiesDetailsByAssetGroupTest() throws Exception {

		List<Map<String, Object>> vulnerabilitiesDetails = new ArrayList<Map<String, Object>>();
		Map<String, Object> map = new HashMap<String, Object>();
		Map<String, Object> map1 = new HashMap<String, Object>();
		Map<String, String> mapf = new HashMap<String, String>();
		map.put("ac", "66");
		map.put("acname", "second");
		map.put("res", "int");
		map.put("vp", "brt3");
		map.put("geid", "amigo");
		map1.put("rr", "345");
		map1.put("fd", "sec");
		map1.put("ij", "i");
		map1.put("cid", "b3");
		map1.put("mad", "mi");
		vulnerabilitiesDetails.add(map);
		vulnerabilitiesDetails.add(map1);

		List<Map<String, Object>> resourceIdDetails = new ArrayList<Map<String, Object>>();
		List<Map<String, Object>> abc = new ArrayList<Map<String, Object>>();
		Map<String, Object> map2 = new HashMap<String, Object>();
		Map<String, Object> map3 = new HashMap<String, Object>();
		map2.put("s", "s3445");
		map2.put("ced", "866");
		map2.put("cif=", "1");
		map2.put("lna", "21.0");
		map2.put("cat", "pp");
		map3.put("ver", "fr");
		map3.put("ed", "cd85");
		map3.put("ifl=", "1");
		map3.put("ule", "2261.0");
		map3.put("sif", "app7");
		resourceIdDetails.add(map2);
		resourceIdDetails.add(map3);
		String assetGroup = "abc";
		Map<String, Object> mustFilter = new HashMap<>();
		Map<String, Object> mustTermsFilter = new HashMap<>();
		mustFilter.put("latest", "true");
		String targetType = "vulninfo";
		String searchText = "";
		int from = 0;
		int size = 0;
		List<String> occurrenceFieldList = null;

		ReflectionTestUtils.setField(vulnerabilityService, "vulnTypes", "ec2");
		ReflectionTestUtils.setField(vulnerabilityService, "vulnOccurrenceFields",
				"severity,_resourceid,pciflag,_vulnage,vulntype,title,classification,_status,qid,patchable,category");
		ReflectionTestUtils.setField(vulnerabilityService, "vulnResourceIdFields",
				"tags.Name,accountid,accountname,tags.Environment,tags.Application,privateipaddress,instanceid,region,availabilityzone,imageid,platform,privatednsname,instancetype,subnetid,_resourceid,publicipaddress,publicdnsname,vpcid");
		ReflectionTestUtils.setField(vulnerabilityService, "vulnResourceIdFieldsBoth",
				"tags.Name,accountid,accountname,tags.Environment,tags.Application,privateipaddress,instanceid,region,availabilityzone,imageid,platform,privatednsname,instancetype,subnetid,_resourceid,publicipaddress,publicdnsname,vpcid");
		when(vulnerabilityRepository.getAllVulnerabilitiesByAssetGroup(assetGroup, targetType, mustFilter,
				occurrenceFieldList, from, size, mustTermsFilter)).thenReturn(vulnerabilitiesDetails);

		when(vulnerabilityRepository.getDetailsByResourceId(anyString(), anyMap(), anyList(), anyMap()))
				.thenReturn(resourceIdDetails);

		assertThat(vulnerabilityService.getAllVulnerabilitiesDetailsByAssetGroup(assetGroup, mapf, "pac", "pro",
				searchText, from, size), is(notNullValue()));

		size = 25;

		ReflectionTestUtils.setField(vulnerabilityService, "vulnOccurrenceFields",
				"severity,_resourceid,pciflag,_vulnage,vulntype,title,classification,_status,qid,patchable,category");
		ReflectionTestUtils.setField(vulnerabilityService, "vulnResourceIdFields",
				"tags.Name,accountid,accountname,tags.Environment,tags.Application,privateipaddress,instanceid,region,availabilityzone,imageid,platform,privatednsname,instancetype,subnetid,_resourceid,publicipaddress,publicdnsname,vpcid");

		when(vulnerabilityRepository.getAllVulnerabilitiesByAssetGroup(assetGroup, targetType, mustFilter,
				occurrenceFieldList, from, size, mustTermsFilter)).thenReturn(vulnerabilitiesDetails);

		when(vulnerabilityRepository.getDetailsByResourceId(anyString(), anyMap(), anyList(), anyMap()))
				.thenReturn(resourceIdDetails);

		assertThat(vulnerabilityService.getAllVulnerabilitiesDetailsByAssetGroup(assetGroup, mapf, "pac", "pro",
				searchText, from, size), is(notNullValue()));

	}

	@SuppressWarnings("unchecked")
	/*@Test
	public void getResourcedetailsByResourceIdTest() throws Exception {

		List<String> resourceDetails = new ArrayList<>();
		String asset = "abc";
		boolean flag = false;
		ReflectionTestUtils.setField(vulnerabilityService, "vulnResourceIdFields",
				"tags.Name,accountid,accountname,tags.Environment,tags.Application,privateipaddress,instanceid,region,availabilityzone,imageid,platform,privatednsname,instancetype,subnetid,_resourceid,publicipaddress,publicdnsname,vpcid");
		ReflectionTestUtils.setField(vulnerabilityService, "vulnResourceIdFieldsBoth",
				"tags.Name,accountid,accountname,tags.Environment,tags.Application,privateipaddress,instanceid,region,availabilityzone,imageid,platform,privatednsname,instancetype,subnetid,_resourceid,publicipaddress,publicdnsname,vpcid");
		when(vulnerabilityRepository.getDetailsByResourceId(anyString(), anyMap(), anyList(), anyMap()))
				.thenReturn(resourceDetails);
		assertThat(vulnerabilityService.getResourcedetailsByResourceId(asset, resourceDetails, flag),
				is(notNullValue()));
	}*/

	@Test
	public void getResourceIdTest() throws Exception {

		List<Map<String, Object>> resourceIdDetails = new ArrayList<Map<String, Object>>();
		Map<String, Object> map2 = new HashMap<String, Object>();
		Map<String, Object> map3 = new HashMap<String, Object>();
		map2.put("s", "s3445");
		map2.put("ced", "866");
		map2.put("cif=", "1");
		map2.put("lna", "21.0");
		map2.put("cat", "pp");
		map3.put("ver", "fr");
		map3.put("ed", "cd85");
		map3.put("ifl=", "1");
		map3.put("ule", "2261.0");
		map3.put("sif", "app7");
		resourceIdDetails.add(map2);
		resourceIdDetails.add(map3);

		assertThat(vulnerabilityService.getResourceId(resourceIdDetails), is(notNullValue()));
	}

	@Test
	public void getCartesianProductTest() throws Exception {

		List<Map<String, Object>> resourceIdDetails = new ArrayList<Map<String, Object>>();
		List<Map<String, Object>> vulnerabilityOccuranceList = new ArrayList<Map<String, Object>>();

		assertThat(vulnerabilityService.getCartesianProduct(vulnerabilityOccuranceList, resourceIdDetails),
				is(notNullValue()));
	}

}
